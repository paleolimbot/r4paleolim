[
["index.html", "R for Paleolimnology Introduction 0.1 Prerequisites 0.2 Other places to learn R/RStudio/tidyverse 0.3 Colophon", " R for Paleolimnology Brent Thorne and Dewey Dunnington 2018-05-02 Introduction TODO: write this section 0.1 Prerequisites R, RStudio, tidyverse TODO: installing R and RStudio 0.2 Other places to learn R/RStudio/tidyverse The book “R for Data Science” (Grolemund and Wickham 2017) (free online version at http://r4ds.had.co.nz/index.html) The Introduction to the tidyverse Data Camp course by David Robinson. tidyverse, visualization, and manipulation basics tutorial from Garrett Grolemund 0.3 Colophon This course material was written using the bookdown package inside RStudio. Pages were built using Travis CI, pandoc and gitbook. The source is available on github. These tutorials were built with: devtools::session_info(pkgs = c(&quot;tidyverse&quot;)) ## Session info ------------------------------------------------------------- ## setting value ## version R version 3.5.0 (2017-01-27) ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## tz UTC ## date 2018-05-02 ## Packages ----------------------------------------------------------------- ## package * version date source ## assertthat 0.2.0 2017-04-11 cran (@0.2.0) ## backports 1.1.2 2017-12-13 cran (@1.1.2) ## base64enc 0.1-3 2015-07-28 cran (@0.1-3) ## BH 1.66.0-1 2018-02-13 cran (@1.66.0-) ## bindr 0.1.1 2018-03-13 cran (@0.1.1) ## bindrcpp 0.2.2 2018-03-29 cran (@0.2.2) ## broom 0.4.4 2018-03-29 cran (@0.4.4) ## callr 2.0.3 2018-04-11 cran (@2.0.3) ## cellranger 1.1.0 2016-07-27 cran (@1.1.0) ## cli 1.0.0 2017-11-05 cran (@1.0.0) ## colorspace 1.3-2 2016-12-14 cran (@1.3-2) ## compiler 3.5.0 2018-04-23 local ## crayon 1.3.4 2017-09-16 cran (@1.3.4) ## curl 3.2 2018-03-28 CRAN (R 3.5.0) ## DBI 0.8 2018-03-02 cran (@0.8) ## dbplyr 1.2.1 2018-02-19 cran (@1.2.1) ## debugme 1.1.0 2017-10-22 cran (@1.1.0) ## dichromat 2.0-0 2013-01-24 cran (@2.0-0) ## digest 0.6.15 2018-01-28 CRAN (R 3.5.0) ## dplyr 0.7.4 2017-09-28 cran (@0.7.4) ## evaluate 0.10.1 2017-06-24 cran (@0.10.1) ## forcats 0.3.0 2018-02-19 cran (@0.3.0) ## foreign 0.8-70 2017-11-28 CRAN (R 3.5.0) ## ggplot2 2.2.1 2016-12-30 cran (@2.2.1) ## glue 1.2.0 2017-10-29 cran (@1.2.0) ## graphics * 3.5.0 2018-04-23 local ## grDevices * 3.5.0 2018-04-23 local ## grid 3.5.0 2018-04-23 local ## gtable 0.2.0 2016-02-26 cran (@0.2.0) ## haven 1.1.1 2018-01-18 cran (@1.1.1) ## highr 0.6 2016-05-09 cran (@0.6) ## hms 0.4.2 2018-03-10 cran (@0.4.2) ## htmltools 0.3.6 2017-04-28 cran (@0.3.6) ## httr 1.3.1 2017-08-20 CRAN (R 3.5.0) ## jsonlite 1.5 2017-06-01 CRAN (R 3.5.0) ## knitr 1.20 2018-02-20 cran (@1.20) ## labeling 0.3 2014-08-23 cran (@0.3) ## lattice 0.20-35 2017-03-25 CRAN (R 3.5.0) ## lazyeval 0.2.1 2017-10-29 cran (@0.2.1) ## lubridate 1.7.4 2018-04-11 cran (@1.7.4) ## magrittr 1.5 2014-11-22 cran (@1.5) ## markdown 0.8 2017-04-20 cran (@0.8) ## MASS 7.3-49 2018-02-23 CRAN (R 3.5.0) ## methods * 3.5.0 2018-04-23 local ## mime 0.5 2016-07-07 CRAN (R 3.5.0) ## mnormt 1.5-5 2016-10-15 cran (@1.5-5) ## modelr 0.1.1 2017-07-24 cran (@0.1.1) ## munsell 0.4.3 2016-02-13 cran (@0.4.3) ## nlme 3.1-137 2018-04-07 CRAN (R 3.5.0) ## openssl 1.0.1 2018-03-03 CRAN (R 3.5.0) ## parallel 3.5.0 2018-04-23 local ## pillar 1.2.2 2018-04-26 cran (@1.2.2) ## pkgconfig 2.0.1 2017-03-21 cran (@2.0.1) ## plogr 0.2.0 2018-03-25 cran (@0.2.0) ## plyr 1.8.4 2016-06-08 cran (@1.8.4) ## praise 1.0.0 2015-08-11 cran (@1.0.0) ## psych 1.8.3.3 2018-03-30 cran (@1.8.3.3) ## purrr 0.2.4 2017-10-18 cran (@0.2.4) ## R6 2.2.2 2017-06-17 CRAN (R 3.5.0) ## RColorBrewer 1.1-2 2014-12-07 cran (@1.1-2) ## Rcpp 0.12.16 2018-03-13 cran (@0.12.16) ## readr 1.1.1 2017-05-16 cran (@1.1.1) ## readxl 1.1.0 2018-04-20 cran (@1.1.0) ## rematch 1.0.1 2016-04-21 cran (@1.0.1) ## reprex 0.1.2 2018-01-26 cran (@0.1.2) ## reshape2 1.4.3 2017-12-11 cran (@1.4.3) ## rlang 0.2.0 2018-02-20 cran (@0.2.0) ## rmarkdown 1.9 2018-03-01 cran (@1.9) ## rprojroot 1.3-2 2018-01-03 cran (@1.3-2) ## rstudioapi 0.7 2017-09-07 CRAN (R 3.5.0) ## rvest 0.3.2 2016-06-17 cran (@0.3.2) ## scales 0.5.0 2017-08-24 cran (@0.5.0) ## selectr 0.4-1 2018-04-06 cran (@0.4-1) ## stats * 3.5.0 2018-04-23 local ## stringi 1.1.7 2018-03-12 cran (@1.1.7) ## stringr 1.3.0 2018-02-19 cran (@1.3.0) ## testthat 2.0.0 2017-12-13 cran (@2.0.0) ## tibble 1.4.2 2018-01-22 cran (@1.4.2) ## tidyr 0.8.0 2018-01-29 cran (@0.8.0) ## tidyselect 0.2.4 2018-02-26 cran (@0.2.4) ## tidyverse 1.2.1 2017-11-14 cran (@1.2.1) ## tools 3.5.0 2018-04-23 local ## utf8 1.1.3 2018-01-03 cran (@1.1.3) ## utils * 3.5.0 2018-04-23 local ## viridisLite 0.3.0 2018-02-01 cran (@0.3.0) ## whisker 0.3-2 2013-04-28 CRAN (R 3.5.0) ## withr 2.1.2 2018-03-15 CRAN (R 3.5.0) ## xml2 1.2.0 2018-01-24 cran (@1.2.0) ## yaml 2.1.19 2018-05-01 cran (@2.1.19) References "],
["basic-r.html", "Tutorial 1 Basic R 1.1 Prerequisites 1.2 Expressions and Variables 1.3 Functions 1.4 Vectors 1.5 Indexing 1.6 Missing Values 1.7 Data Frames 1.8 Loading Packages 1.9 Using the Script Editor 1.10 The Environment 1.11 Excercises 1.12 Summary", " Tutorial 1 Basic R When you open RStudio, you are presented with the ominous &gt; of the R console. By the end of this tutorial, hopefully that &gt; should fill you with a feeling of hope and opportunity, for magical things can happen when you type the right thing after the &gt;. This short introduction will get you started with the R console so that when we introduce more powerful functions, you can understand what R is doing at the base level! The tutorial is loosely based on the Workflow: basics tutorial in the free online book, R for Data Science (Grolemund and Wickham 2017). The basic R console. 1.1 Prerequisites The prerequisite for this tutorial is the tidyverse package. If this package isn’t installed, you’ll have to install it using install.packages(), which you can type after the &gt;. install.packages(&quot;tidyverse&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) ## ── Attaching packages ────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 2.2.1 ✔ purrr 0.2.4 ## ✔ tibble 1.4.2 ✔ dplyr 0.7.4 ## ✔ tidyr 0.8.0 ✔ stringr 1.3.0 ## ✔ readr 1.1.1 ✔ forcats 0.3.0 ## ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 1.2 Expressions and Variables Let’s start with the basics. Try typing in something like this at the prompt: 1 + 1 ## [1] 2 2 * 5 ## [1] 10 5 ^ 2 ## [1] 25 2 * (5 + 1) ## [1] 12 As you can see, R works just like a calculator and evaluates all of these expressions just like you would expect. If we would like to save the result of one of these expressions we can assign that value to a variable like this: x &lt;- 1 + 1 Then, to view the value of x we can just type x at the console, and R will show us the value. x ## [1] 2 The &lt;- means “assign the value on the right to the variable on the left”. We can also use x in any expression and R will substitute its value in like this: x + 2 ## [1] 4 An expression is something that R can evaluate to produce a value, like 2+2 or x + 2. Any time you type this in the console without assigning it to a variable, R will print out the value. In fact, any time you type anything into the R console, R is evaluating that expression, which may or may not return a value. If there is no value returned, R won’t print anything when you press enter. So far we’ve just used numbers, but often we need to enter text into R. Whenever we do this, we surround the text in quotes, like this: mytext &lt;- &quot;I am text&quot; Text (called character vectors) are one of many data types available in R. 1.3 Functions A function is some kind of operation that takes one or more arguments (input values) and produces a return value (output value). The sqrt() function is a good example: sqrt(4) ## [1] 2 Here, 4 is an argument, and the function returns the square root of that, which is 2. Functions can take more arguments, like the max function: max(2, 6, 7, 2, 10) ## [1] 10 Here we are giving the max function 5 arguments, of which it returns the maximum. One other way we specify arguments is by keyword arguments, like in the paste function. paste(&quot;string1&quot;, &quot;string2&quot;, sep = &quot;_&quot;) ## [1] &quot;string1_string2&quot; The paste function takes its arguments and combines them using the sep that we specify, in this case &quot;_&quot;. The function returns this string. Many functions in R have many many arguments and usually we only want to modify one or two of interest to us. The format is always key=value, where key is the name of the keyword and value is some expression we would like to use as the value for that argument. R contains thousands of functions that do most of what you could possibly imagine with regards to data and statistics, but remembering which one you want and how to use it can be difficult. Luckily, RStudio makes it easy using tab autocompletion and easy access to help files. To autocomplete, start typing the name of the function and press the [Tab] key (or Ctrl+Space), and RStudio will helpfully provide you with suggestions. To access the documentation for a particular function, you can type ? in front of the function name and press return, and RStudio will open the help file for you if it exists. ?paste Will bring up the following: 1.3 Description Concatenate vectors after converting to character. 1.3 Usage paste (..., sep = &quot; &quot;, collapse = NULL) paste0(..., collapse = NULL) 1.3 Arguments … one or more R objects, to be converted to character vectors. sep a character string to separate the terms. Not NA_character_. collapse an optional character string to separate the results. Not NA_character_. Note that each of these arguments can be specified by keyword, and have default values that we can see in the usage section. The ... means that we can pass any number of arguments to the function. There’s too many functions in R to keep in your head at one time, so getting good at reading these help files is very useful! 1.4 Vectors So far we’ve just been dealing with single values like 2+2 or &quot;mystring&quot;, but the real power of R is that it can operate easily on large lists of data, so it makes sense that it provides us with an easy way to work with this data. These lists of data are called vectors, and we create them using the c function (c stands for concatenate, or join together). myvector &lt;- c(10, 9, 8, 7, 2) myvector ## [1] 10 9 8 7 2 Here the c function took our arguments of 10, 9, 8, 7, and 2, and returned a vector, which we assigned to the variable named myvector. When we evaluated myvector, it printed out the list of values it contained. Vectors don’t just have to contain numbers, they can contain strings as well. mytextvector &lt;- c(&quot;word1&quot;, &quot;word2&quot;, &quot;word3&quot;) mytextvector ## [1] &quot;word1&quot; &quot;word2&quot; &quot;word3&quot; Here the c function took our arguments and returned a vector of strings, which we assigned to the variable mytextvector. It is common to have to generate a vector of all the integer values between two numbers, so R provides a short form for this: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 20:12 ## [1] 20 19 18 17 16 15 14 13 12 myothervector &lt;- 13:16 myothervector ## [1] 13 14 15 16 You can also use an expression on either side of the :, like this: (5^2):(3*10) ## [1] 25 26 27 28 29 30 start &lt;- 25 end &lt;- start + 5 start:end ## [1] 25 26 27 28 29 30 1.5 Indexing Now we’ve created vectors, but to get at what’s inside them we need to retrieve values using an index. We do this using square brackets like this: myvector &lt;- c(10, 9, 8, 7, 2) myvector[1] ## [1] 10 myvector[5] ## [1] 2 myvector[3] ## [1] 8 This code creates a vector, assigns it to the variable myvector, then retrieves the 1st, 5th, and 3rd value stored in that vector. If we would like multiple values from the vector, we can pass multiple values as indices, like this: myvector[c(1, 5, 3)] ## [1] 10 2 8 You’ll notice that the index that we’re using is actually a vector itself! I know, we’re using a vector to index a vector and it’s a little trippy, but it’s incredibly useful. You’ll remember that we can easily create vectors of sequential integers, which we can use to get a sequence of values from a vector by using it as an index. myvector[1:3] ## [1] 10 9 8 This would be equivalent to: myvector[c(1, 2, 3)] ## [1] 10 9 8 There is one other useful way to index a vector using a vector, which is to use a TRUE/FALSE vector. This is probably the most useful of the indexing methods, because it allows you to do things like: myvector[myvector &gt; 7] ## [1] 10 9 8 This works because myvector &gt; 7 is, itself, a TRUE/FALSE vector with the same length as myvector, indicating whether or not it is greater than 7 at any given position. myvector &gt; 7 ## [1] TRUE TRUE TRUE FALSE FALSE 1.6 Missing Values Missing values are represented in R using NA, or “not assigned”. The fact that R handles missing values is one of the best reasons to use R for data analysis, because missing values are common in real data. NA values are propogated by R functions, meaning that if you take the mean() of a vector containing a missing value, it will give you NA as the average! mean(c(NA, 1, 2, 3)) ## [1] NA This is rarely what you want, but is a good practice to explicitly handle missing values in your code, and R forces you to do this. To avoid getting an NA back, you can use na.rm = TRUE, an argument that is available in many R functions. mean(c(NA, 1, 2, 3), na.rm = TRUE) ## [1] 2 1.7 Data Frames The vast majority of data in R is kept in a tibble (often called a data frame), which is a collection of vectors of the same length. You can think of a tibble as a table, with each column in the table being of the same type (numeric, character, TRUE/FALSE, etc.). my_tibble &lt;- tibble( number = c(1, 2, 3), name = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), is_one = c(TRUE, FALSE, FALSE) ) my_tibble ## # A tibble: 3 x 3 ## number name is_one ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 one TRUE ## 2 2 two FALSE ## 3 3 three FALSE The syntax for creating a tibble is tibble(column_name = value). The above tibble has three columns (number, a numeric column, name, a character column, and is_one, a logical TRUE/FALSE column). You can get these values as vectors again using the $ operator, which allows you to extract a vector from a data frame. my_tibble$number ## [1] 1 2 3 my_tibble$name ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; my_tibble$is_one ## [1] TRUE FALSE FALSE You can think of tibbles as a collection of vectors (variables) having the same number of elements. The number of elements has to be equal for all columns, meaning the ith value of each vector forms an observation. Data in this form is very useful and is the subject of most of the following tutorials. 1.8 Loading Packages Basic R functionality is designed to provide basic functions to help with data analysis, but may add-ons are available and code you find online (including here, shortly) will often tell you to load a “package” using library(). This will be a call to the library() function in the form library(packagename), where packagename is the name of the package which contains the functions you are interested in using (all of the subsequent tutorials will use library(tidyverse), because the tidyverse package contains many useful functions that you will use on a regular basis. When you call library(packagename), it will make these functions available to you. Occasionally you will see something like packagename::function_name(), which is a method to use a function without making all of the functions in a package. This is equivalent to typing library(packagename) then function_name() on the next line. You can install packages using install.packages(&quot;packagename&quot;) (note the quotes around packagename!). For example, let’s install the tidyverse package now, since you’ll be using it in the rest of this series. install.pacakges(&quot;tidyverse&quot;) Then, load it using library(): library(tidyverse) Finally, we are ready to call a function from the package. The tidyverse package actually installs and loads a family of useful packages for us, a list of which we can access using tidyverse_packages(). Try it! tidyverse_packages() ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; 1.9 Using the Script Editor In reality, very little of the code you type will be directly in the prompt. Instead, you will use RStudio’s script editor to run commands so that you can go back and edit them or run them from the beginning. To create a new R script, choose File, New File, and R script (you can also choose the little green “+” button at the top left of the console window). A blank R script should appear in a new tab. A new R script in the RStudio script editor. When you type a command in the editor and press enter, nothing happens! This is because the editor is meant to build script that contain multiple lines, unlike the console, which is meant to execute a single line at a time. To run a command you have typed in the script editor, press Ctrl+Enter (Command+Enter on a Mac). You can even select multiple lines, press Ctrl+Enter, and they will all run at once! You can also save the script and choose Source to run the whole thing. It is good practice to keep all of your code in a script somewhere. Typing it on a console repeatedly is hard work, and leads to errors! 1.10 The Environment When you’ve assigned a bunch of variables, it can be tricky to keep track of which ones are where and contain what! Hopefully you have given them short but descriptive names, but if you happen to forget you can check the “Environment” tab in RStudio (in the upper right part of the window). If you’d like to start fresh you can clear the environment (use the little broom icon or go to Session/Clear Workspace), and if you really want to start fresh, you can restart R using Session/Restart R. This will clear your workspace and unload all the packages you loaded using library(). This is a good way to make sure all of your analysis has been encapsulated by the script, since you can Restart R and Source your script to replicate your work. The RStudio Environment Tab By default, R will save your session when you quit and reload the variables you had previously assigned when you reopen it. This is dangerous, because even though you created an object, you may not be able to create it again! I highly reccomend using the script editor to encapsulate all of your code, and disable the automatic loading/saving of your workspace. You can do this in RStuio’s Preferences (or “Global Options” on Windows/Linux) by setting “Save workspace on exit” to “Never”, and unchecking “Restore .RData into workspace at startup”. The RStudio Global Options/Preferences window. 1.11 Excercises To practice the basics of R, complete the very first swirl module, R Programming / Basic Building Blocks. To do this, you’ll need to install and load swirl by typing this at the R prompt: install.packages(&quot;swirl&quot;) library(swirl) swirl() You should get a friendly greeting that will prompt you to choose a course (you want number 1, “R Programming: The basics of programming in R”) and a module (you want number 1, “Basic Building Blocks”). I suggest stopping after the first module, as R for Data Science provides a more effective introduction to the language. 1.12 Summary In this lesson we covered expressions, variables, functions, vectors, and indexing, all of which will help you get the most out of the tutorials in this series. For more information, check out the Workflow: basics and Workflow: scripts tutorial in the free online book, R for Data Science. References "],
["working-with-tables-using-the-tidyverse.html", "Tutorial 2 Working with Tables using the Tidyverse 2.1 Prerequisites 2.2 Viewing a Data Frame 2.3 Selecting Columns 2.4 Filtering Rows 2.5 Selecting and Filtering 2.6 The Pipe (%&gt;%) 2.7 Arranging (sorting) A Data Frame 2.8 Distinct Values 2.9 Calculating columns using mutate() 2.10 Summarising A Data Frame 2.11 Extracting Columns 2.12 Base R Subsetting vs. select() and filter() 2.13 Summary", " Tutorial 2 Working with Tables using the Tidyverse In this tutorial we will introduce the tibble (also called a data frame), or the object type that R uses to store tables. Most of the data you will work with in R can be represented by a table (think an excel sheet), and one of the main advantages of using R is that the data frame is a powerful and intuitive interface for tabular data. In this tutorial we will use the tidyverse to manipulate and summarise tabular data. The tutorial is a companion to the Data transformation chapter in R for Data Science. 2.1 Prerequisites The prerequisite for this tutorial is the tidyverse package. If this package isn’t installed, you’ll have to install it using install.packages(). install.packages(&quot;tidyverse&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) Finally, you will need to load the example data. For now, copy and paste the following code to load the Halifax geochemistry dataset (we will learn how to read various types of files into R in the preparing and loading data tutorial). halifax_geochem &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/halifax_geochem.csv&quot;, col_types = cols(.default = col_guess()) ) It’s worth mentioning a little bit about what this data frame contains, since we’ll be working with it for the rest of this tutorial. The data contains several bulk geochemical parameters from a recent study of Halifax drinking water reservoirs (Dunnington et al. 2018), including Pockwock Lake, Lake Major, Bennery Lake, Lake Fletcher, Lake Lemont, First Chain Lake, First Lake, and Second Lake. (Later, we will take a look at the core locations as well as the geochemical data). 2.2 Viewing a Data Frame The variable we have just created (halifax_geochem) is a tibble, which is a table of values much like you would find in a spreadsheet (you will notice that we loaded it directly from an Excel spreadhseet). Each column in the tibble represents a variable (in this case, the core identifier, depth of the sample, age represented by that sample, and several geochemical parameters), and each row in the table represents an observation (in this case, a sample from a sediment core). In RStudio’s “Environment” tab (usually at the top right of the screen), you should see a variable called halifax_geochem in the list. You can inspect it by clicking on the variable name, after which a tab will appear displaying the contents of the variable you just loaded. Clicking the little arrow to the left of the name will display the structure of the data frame, including the column names and some sample values. You can also do both of these things using the R commands View() and glimpse(), respectively. Also useful is the head() function, which will display the first few rows of a data frame. View(halifax_geochem) # will display a graphic table browser glimpse(halifax_geochem) # will display a text summary of the object ## Observations: 326 ## Variables: 9 ## $ core_id &lt;chr&gt; &quot;BEN15-2&quot;, &quot;BEN15-2&quot;, &quot;BEN15-2&quot;, &quot;BEN15-2&quot;, &quot;BEN... ## $ depth_cm &lt;dbl&gt; 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5... ## $ age_ad &lt;dbl&gt; 2015.903, 2015.188, 2014.474, 2012.950, 2011.425... ## $ C_percent &lt;dbl&gt; 14.75718, 14.65701, 14.94983, 14.54558, 14.40408... ## $ `C/N` &lt;dbl&gt; 12.15765, 12.17829, 11.92338, 11.67900, 11.61200... ## $ d13C_permille &lt;dbl&gt; -30.24752, -30.31042, -30.35799, -30.33835, -30.... ## $ d15N_permille &lt;dbl&gt; 2.461962, 2.447662, 2.336219, 2.528572, 2.662515... ## $ K_percent &lt;dbl&gt; 1.0026000, 1.0857000, 0.9782000, 0.9423000, 1.07... ## $ Ti_percent &lt;dbl&gt; 0.1693000, 0.1823000, 0.1678000, 0.1664000, 0.18... head(halifax_geochem) # will display the first few rows of the data ## # A tibble: 6 x 9 ## core_id depth_cm age_ad C_percent `C/N` d13C_permille d15N_permille ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 0 2016. 14.8 12.2 -30.2 2.46 ## 2 BEN15-2 0.5 2015. 14.7 12.2 -30.3 2.45 ## 3 BEN15-2 1 2014. 14.9 11.9 -30.4 2.34 ## 4 BEN15-2 1.5 2013. 14.5 11.7 -30.3 2.53 ## 5 BEN15-2 2 2011. 14.4 11.6 -30.4 2.66 ## 6 BEN15-2 2.5 2010. 14.4 11.9 -30.3 2.48 ## # ... with 2 more variables: K_percent &lt;dbl&gt;, Ti_percent &lt;dbl&gt; 2.3 Selecting Columns One way to subset halifax_geochem is to subset by column, for which we will use the select() function. For example, we may only be interested in the stable isotope information, represented by the columns d13C_permille and d15N_permille. stable_isotope_data &lt;- select( halifax_geochem, core_id, depth_cm, age_ad, d13C_permille, d15N_permille ) The first argument to the select() function is the original data frame (in this case, halifax_geochem), and the remaining arguments are the names of the columns to be selected. To select the core_id, age_ad, Ti, and K columns, you would use the following R command: geochem_data &lt;- select(halifax_geochem, core_id, depth_cm, age_ad, Ti_percent, K_percent) Some column names in halifax_geochem contain characters that could be interpreted as an operation (e.g., C/N, which is the name of the column and not C divided by N). To select these columns, you will need to surround the column name in backticks: select(halifax_geochem, core_id, depth_cm, age_ad, `C/N`) 2.3.1 Excercises Use View(), glimpse(), and head() to preview the two data frames we just created. Do they have the columns you would expect? Use select() to select core_id, depth_cm, C/N, d13C, and d15N, and assign it to the variable cn_data. 2.4 Filtering Rows Another way to subset halifax_geochem is by filtering rows using column values, similar to the filter feature in Microsoft Excel. This is done using the filter() function. For example, we may only be interested in the core from Pockwock Lake. pockwock_data &lt;- filter(halifax_geochem, core_id == &quot;POC15-2&quot;) Just like select(), the first argument to filter() is the original data frame, and the subsequent arguments are the conditions that each row must satisfy in order to be included in the output. Column values are referred to by the column name (in the above example, core_id), so to include all rows where the value in the core_id column is POC15-2, we use core_id == &quot;POC15-2&quot;. Passing multiple conditions means each row must satisfy all of the conditions, such that to obtain the data from core POC15-2 where the depth in the core was 0 cm, we can use the following call to filter(): pockwock_surface_data &lt;- filter(halifax_geochem, core_id == &quot;POC15-2&quot;, depth_cm == 0) It is very important that there are two equals signs within filter()! The == operator tests for equality (e.g. (2 + 2) == 4), whereas the = operator assigns a value or passes a named argument to a function, which is not what you’re trying to do within filter(). Other common operators that are useful within filter are != (not equal to), &gt; (greater than), &lt; (less than), &gt;= (greater than or equal to), &lt;= (less than or equal to), and %in% (tests if the value is one of several values). Using these, we could find out which observations are representative of the era 1950 to present: data_recent &lt;- filter(halifax_geochem, age_ad &gt;= 1950) We could also find observations from multiple cores: pockwock_major_data &lt;- filter(halifax_geochem, core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) 2.4.1 Exercises Use View(), glimpse(), and head() to preview the data frames we just created. Do they have the rows you would expect? Use filter() to find observations from the core FCL16-1 with an age between 1900 and present, and assign it to a name of your choosing. Are there any observations with a C/N value greater than 20? (hint: you will have to surround C/N in backticks) 2.5 Selecting and Filtering Often we need to use both select() and filter() to obtain the desired subset of a data frame. To do this, we need to pass the result of select() to filter(), or the result of filter() to select. For example, we could create a data frame of recent (age greater than 1950) stable isotope measurements (you’ll recall that we selected stable isotope columns in the data frame stable_isotope_data): recent_stable_isotopes &lt;- filter(stable_isotope_data, age_ad &gt;= 1950) recent_stable_isotopes2 &lt;- select( data_recent, core_id, depth_cm, age_ad, d13C_permille, d15N_permille ) 2.5.1 Exercises Use View(), glimpse(), and/or head() to verify that recent_stable_isotopes and recent_stable_isotopes_2 are identical. 2.6 The Pipe (%&gt;%) There is an easier way! Instead of creating intermediary variables every time we want to subset a data frame using select() and filter(), we can use the pipe operator (%&gt;%) to pass the result of one function call to another. Thus, creating our recent_stable_isotopes data frame from above becomes one line with one variable assignment instead of two. recent_stable_isotopes_pipe &lt;- halifax_geochem %&gt;% filter(age_ad &gt;= 1950) %&gt;% select(core_id, depth_cm, age_ad, d13C_permille, d15N_permille) What %&gt;% does is pass the left side into the first argument of the function call on the right side. Thus, filter(halifax_geochem, age_ad &gt;= 1950) becomes halifax_geochem %&gt;% filter(age_ad &gt;= 1950). When using the tidyverse family of packages, you should use the pipe as often as possible! It usually makes for more readable, less error-prone code, and reduces the number of temporary variables you create that clutter up your workspace. When using filter() and select() with other tidyverse manipulations like arrange(), group_by(), summarise(), and mutate(), the pipe becomes indispensable. 2.6.1 Exercises Inspect recent_stable_isotopes_pipe to ensure it is identical to recent_stable_isotopes. Create a data frame of stable isotope data from surface samples (depth_cm == 0) using halifax_geochem, filter(), select(), and %&gt;% and assign it to a variable of a suitable name. 2.7 Arranging (sorting) A Data Frame Sometimes it is desirable to view rows in a particular order, which can be used to quickly determine min and max values of various parameters. You can do this in the interactive editor using View(), but sometimes rows need to be in particular order for plotting or other analysis. This is done using the arrange() function. For example, it may make sense to view halifax_geochem in ascending core_id and depth_cm order (most recent first): halifax_geochem %&gt;% arrange(core_id, depth_cm) ## # A tibble: 326 x 9 ## core_id depth_cm age_ad C_percent `C/N` d13C_permille d15N_permille ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 0 2016. 14.8 12.2 -30.2 2.46 ## 2 BEN15-2 0.5 2015. 14.7 12.2 -30.3 2.45 ## 3 BEN15-2 1 2014. 14.9 11.9 -30.4 2.34 ## 4 BEN15-2 1.5 2013. 14.5 11.7 -30.3 2.53 ## 5 BEN15-2 2 2011. 14.4 11.6 -30.4 2.66 ## 6 BEN15-2 2.5 2010. 14.4 11.9 -30.3 2.48 ## 7 BEN15-2 3 2008. 14.4 11.9 -30.3 2.53 ## 8 BEN15-2 3.5 2005. 14.3 12.0 -30.2 2.60 ## 9 BEN15-2 4 2002. 14.0 12.0 -30.2 2.60 ## 10 BEN15-2 4.5 1999. 13.7 12.1 -30.2 2.48 ## # ... with 316 more rows, and 2 more variables: K_percent &lt;dbl&gt;, ## # Ti_percent &lt;dbl&gt; Or descending depth order (most recent last): halifax_geochem %&gt;% arrange(core_id, desc(depth_cm)) ## # A tibble: 326 x 9 ## core_id depth_cm age_ad C_percent `C/N` d13C_permille d15N_permille ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 29 1742. 14.5 13.4 -29.3 3.54 ## 2 BEN15-2 28 1751. 14.5 13.5 -29.3 3.60 ## 3 BEN15-2 27 1759. 15.1 13.4 -29.4 3.60 ## 4 BEN15-2 26 1768. 15.9 13.5 -29.5 3.57 ## 5 BEN15-2 25 1776. 16.7 13.4 -29.6 3.42 ## 6 BEN15-2 24 1784. 16.8 13.4 -29.5 3.42 ## 7 BEN15-2 23 1793. 16.5 13.5 -29.4 3.39 ## 8 BEN15-2 22 1801. 17.2 13.4 -29.4 3.41 ## 9 BEN15-2 21 1810. 17.3 13.6 -29.4 3.22 ## 10 BEN15-2 20 1818. 17.6 13.5 -29.4 3.18 ## # ... with 316 more rows, and 2 more variables: K_percent &lt;dbl&gt;, ## # Ti_percent &lt;dbl&gt; The arrange() function takes columns as arguments, surrounded by desc() if that column should be sorted in descending order. 2.8 Distinct Values It is often useful to know which values exist in a data frame. For example, I’ve told you that the core locations are for various lakes in the halifax area, but what are they actually called in the dataset? To do this, we can use the distinct() function. halifax_geochem %&gt;% distinct(core_id) ## # A tibble: 8 x 1 ## core_id ## &lt;chr&gt; ## 1 BEN15-2 ## 2 FCL16-1 ## 3 FLE16-1 ## 4 FLK12-1 ## 5 LEM16-1 ## 6 MAJ15-1 ## 7 POC15-2 ## 8 SLK13-1 The distinct() function can take any number of column names as arguments, although in this particular dataset there isn’t a good example for this. 2.9 Calculating columns using mutate() To create a brand-new column, we can use the mutate() function. This creates a column in a way that we can use existing column names to calculate a new column. For example, we could convert the age_ad column to years before 1950: halifax_geochem %&gt;% mutate(age_bp = 1950 - age_ad) %&gt;% select(core_id, age_ad, age_bp) ## # A tibble: 326 x 3 ## core_id age_ad age_bp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 2016. -65.9 ## 2 BEN15-2 2015. -65.2 ## 3 BEN15-2 2014. -64.5 ## 4 BEN15-2 2013. -62.9 ## 5 BEN15-2 2011. -61.4 ## 6 BEN15-2 2010. -59.6 ## 7 BEN15-2 2008. -57.8 ## 8 BEN15-2 2005. -54.9 ## 9 BEN15-2 2002. -52.1 ## 10 BEN15-2 1999. -49.3 ## # ... with 316 more rows Or, we could convert the K_percent and Ti_percent columns to parts per million: halifax_geochem %&gt;% mutate( K_ppm = K_percent * 10000, Ti_ppm = Ti_percent * 10000 ) %&gt;% select(core_id, K_percent, K_ppm, Ti_percent, Ti_ppm) ## # A tibble: 326 x 5 ## core_id K_percent K_ppm Ti_percent Ti_ppm ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 1.00 10026 0.169 1693 ## 2 BEN15-2 1.09 10857. 0.182 1823 ## 3 BEN15-2 0.978 9782 0.168 1678 ## 4 BEN15-2 0.942 9423 0.166 1664 ## 5 BEN15-2 1.08 10784. 0.183 1832. ## 6 BEN15-2 1.09 10863 0.183 1830 ## 7 BEN15-2 1.04 10374. 0.176 1762 ## 8 BEN15-2 0.97 9700 0.167 1670 ## 9 BEN15-2 1.12 11175 0.179 1791 ## 10 BEN15-2 1.01 10064. 0.17 1700. ## # ... with 316 more rows 2.10 Summarising A Data Frame So far we have looked at subsets of halifax_geochem, but what if we want per-core averages instead of raw data values? Using the tidyverse, we can group_by() the core_id column, and summarise(): halifax_geochem %&gt;% group_by(core_id) %&gt;% summarise(mean_CN = mean(`C/N`)) ## # A tibble: 8 x 2 ## core_id mean_CN ## &lt;chr&gt; &lt;dbl&gt; ## 1 BEN15-2 12.8 ## 2 FCL16-1 14.2 ## 3 FLE16-1 12.4 ## 4 FLK12-1 12.8 ## 5 LEM16-1 12.6 ## 6 MAJ15-1 NA ## 7 POC15-2 NA ## 8 SLK13-1 NA Here group_by() gets a list of columns, for which each unique combination of values will get one row in the output. summarise() gets a list of expressions that are evaluated for every unique combination of values defined by group_by() (e.g., mean_CN is the mean() of the C/N column for each core). Often, we want to include a number of summary columns in the output, which we can do by pasing more expressions to summarise(): halifax_geochem %&gt;% group_by(core_id) %&gt;% summarise( mean_CN = mean(`C/N`), min_CN = min(`C/N`), max_CN = max(`C/N`), sd_CN = sd(`C/N`) ) ## # A tibble: 8 x 5 ## core_id mean_CN min_CN max_CN sd_CN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 12.8 11.6 13.6 0.648 ## 2 FCL16-1 14.2 12.1 16.5 1.05 ## 3 FLE16-1 12.4 10.5 13.3 0.830 ## 4 FLK12-1 12.8 10.6 14.9 1.02 ## 5 LEM16-1 12.6 11.8 13.1 0.307 ## 6 MAJ15-1 NA NA NA NA ## 7 POC15-2 NA NA NA NA ## 8 SLK13-1 NA NA NA NA You will notice that in for several cores the summary values are NA, or missing. This is because R propogates missing values unless you explicitly tell it not to. To fix this, you could replace mean(`C/N`) with mean(`C/N`, na.rm = TRUE). Other useful functions to use inside summarise() include mean(), median(), sd(), sum(), min(), and max(). These all take a vector of values and produce a single aggregate value suitable for use in summarise(). One special function, n(), you can use (with no arguments) inside summarise() to tell you how many observations were aggregated to produce the values in that row. halifax_geochem %&gt;% group_by(core_id) %&gt;% summarise( mean_CN = mean(`C/N`, na.rm = TRUE), min_CN = min(`C/N`, na.rm = TRUE), max_CN = max(`C/N`, na.rm = TRUE), sd_CN = sd(`C/N`, na.rm = TRUE), n = n() ) ## # A tibble: 8 x 6 ## core_id mean_CN min_CN max_CN sd_CN n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 BEN15-2 12.8 11.6 13.6 0.648 35 ## 2 FCL16-1 14.2 12.1 16.5 1.05 49 ## 3 FLE16-1 12.4 10.5 13.3 0.830 37 ## 4 FLK12-1 12.8 10.6 14.9 1.02 33 ## 5 LEM16-1 12.6 11.8 13.1 0.307 35 ## 6 MAJ15-1 15.7 14.3 18.4 1.09 51 ## 7 POC15-2 15.2 13.6 17.4 1.26 52 ## 8 SLK13-1 11.4 10.3 11.9 0.443 34 It’s always a good idea to include n() inside summarise(), if nothing else as a check to make sure you’ve used group_by() with the correct columns. 2.10.1 Excercises Assign the data frame we just created to a variable, and inspect it using View() and str(). Which cores have the most terrestrial C/N signature? Which cores have the most aquatic signature? Create a similar data frame to the one we just created but using C_percent. Which cores had the highest peak organic value. Which cores had the oldest estimated basal date? 2.11 Extracting Columns When we use select() or distinct(), we get back a data frame, however occasionally we need one or a few of the vectors that make up the data frame (recall from the last tutorial that data frames are a collection of column vectors). If we needed just the temperature values, we can use the $ operator or the pull() function to extract a column vector. halifax_geochem$C_percent ## [1] 14.757176 14.657012 14.949832 14.545579 14.404084 14.403361 14.417744 ## [8] 14.279836 14.013717 13.703397 13.403708 12.918529 12.905447 13.359170 ## [15] 13.852618 14.386124 14.533912 14.593866 15.667289 14.765232 15.028548 ## [22] 15.290797 16.107091 16.828205 17.336513 17.591619 17.311306 17.183589 ## [29] 16.492232 16.808112 16.701580 15.903060 15.069473 14.535988 14.529308 ## [36] 16.865924 15.026170 15.495396 14.920478 14.986076 15.500813 15.359202 ## [43] 15.174549 15.809170 15.493308 13.107648 14.348712 13.259158 13.556510 ## [50] 13.119736 12.610362 12.626289 13.510481 13.516503 13.673926 13.739241 ## [57] 13.319716 12.752857 12.449856 13.769313 13.594019 14.074802 15.168339 ## [64] 16.618788 16.359283 16.105118 16.514953 18.517095 17.978341 17.371192 ## [71] 16.311194 17.566880 17.477789 17.054982 17.685215 17.953537 19.507351 ## [78] 20.374763 20.849903 18.816935 19.815698 20.777122 20.852904 21.074918 ## [85] 6.263526 6.173985 6.054831 5.702408 5.113311 4.834282 4.572133 ## [92] 4.370639 4.433741 4.321790 4.511906 4.997175 5.026973 5.507729 ## [99] 5.613024 6.005021 6.368445 6.736808 7.413337 7.826077 8.387502 ## [106] 8.641869 9.651663 10.471288 11.024577 11.867441 9.647337 11.459685 ## [113] 11.809470 12.079710 11.911566 12.071773 12.279458 12.478523 12.579303 ## [120] 12.571033 12.838081 4.533660 4.587350 4.313170 4.358330 4.424750 ## [127] 4.803090 7.139540 9.071560 9.337890 9.629480 9.318650 10.515000 ## [134] 9.964780 11.282600 10.048000 10.303900 11.186500 10.948100 9.480070 ## [141] 8.809490 8.579200 8.531470 9.635170 9.138650 9.447680 8.802510 ## [148] 9.611150 9.787400 9.432920 8.768380 8.822690 9.401530 9.579060 ## [155] 14.321988 13.170802 12.511922 10.561964 9.652961 8.523713 7.645318 ## [162] 7.462763 7.544005 7.347211 7.537033 7.310795 7.341749 7.476305 ## [169] 7.421047 7.381802 7.398633 7.934676 8.815771 9.335244 10.760830 ## [176] 11.400979 11.250975 12.138173 12.768363 12.735964 12.427341 12.086503 ## [183] 13.644940 14.713456 15.641560 16.972044 17.678566 17.798798 18.278828 ## [190] NA 16.269317 15.259672 14.197484 14.270182 14.714715 13.955317 ## [197] 13.719997 13.917566 16.450386 20.130244 21.488213 21.169039 20.821857 ## [204] 18.802373 16.951176 15.031508 13.885433 13.419708 13.391310 13.438673 ## [211] 12.997013 12.731380 13.096725 12.781592 12.687495 11.733670 11.623405 ## [218] 12.029799 12.674604 13.561877 15.560322 16.826027 17.238919 16.435055 ## [225] 16.156588 16.386247 15.994739 15.808491 15.335339 15.501906 15.750462 ## [232] 15.813097 15.818069 15.763004 15.763415 15.848448 15.543236 15.343314 ## [239] 15.133554 14.878146 NA 20.122789 NA 21.543915 20.494810 ## [246] 20.208873 20.149571 19.043943 17.930155 16.835701 17.243781 17.922027 ## [253] 17.457315 15.637815 15.053572 15.151438 14.823894 14.666839 14.135732 ## [260] 13.915358 14.326561 14.778377 15.763145 16.940269 17.786186 18.217911 ## [267] 17.992235 18.166406 19.032422 19.143826 18.636600 18.702145 18.130120 ## [274] 18.365359 18.074177 18.062602 18.280654 18.331464 17.700223 17.002926 ## [281] 17.245358 17.465165 17.076685 16.854514 16.893483 16.955922 16.795793 ## [288] 16.874876 16.822462 16.450231 16.734635 16.486585 5.704334 5.306090 ## [295] NA 5.350935 5.207219 5.303574 5.609634 6.246534 6.315260 ## [302] 6.913474 7.164375 7.701242 7.572774 6.123106 6.953925 6.500808 ## [309] 9.940868 7.538145 11.425805 9.094246 12.094420 12.084451 12.244675 ## [316] 12.116512 12.069895 12.102366 11.977507 11.889317 11.935524 10.761811 ## [323] 11.463138 7.890573 11.445759 11.556214 halifax_geochem %&gt;% pull(C_percent) ## [1] 14.757176 14.657012 14.949832 14.545579 14.404084 14.403361 14.417744 ## [8] 14.279836 14.013717 13.703397 13.403708 12.918529 12.905447 13.359170 ## [15] 13.852618 14.386124 14.533912 14.593866 15.667289 14.765232 15.028548 ## [22] 15.290797 16.107091 16.828205 17.336513 17.591619 17.311306 17.183589 ## [29] 16.492232 16.808112 16.701580 15.903060 15.069473 14.535988 14.529308 ## [36] 16.865924 15.026170 15.495396 14.920478 14.986076 15.500813 15.359202 ## [43] 15.174549 15.809170 15.493308 13.107648 14.348712 13.259158 13.556510 ## [50] 13.119736 12.610362 12.626289 13.510481 13.516503 13.673926 13.739241 ## [57] 13.319716 12.752857 12.449856 13.769313 13.594019 14.074802 15.168339 ## [64] 16.618788 16.359283 16.105118 16.514953 18.517095 17.978341 17.371192 ## [71] 16.311194 17.566880 17.477789 17.054982 17.685215 17.953537 19.507351 ## [78] 20.374763 20.849903 18.816935 19.815698 20.777122 20.852904 21.074918 ## [85] 6.263526 6.173985 6.054831 5.702408 5.113311 4.834282 4.572133 ## [92] 4.370639 4.433741 4.321790 4.511906 4.997175 5.026973 5.507729 ## [99] 5.613024 6.005021 6.368445 6.736808 7.413337 7.826077 8.387502 ## [106] 8.641869 9.651663 10.471288 11.024577 11.867441 9.647337 11.459685 ## [113] 11.809470 12.079710 11.911566 12.071773 12.279458 12.478523 12.579303 ## [120] 12.571033 12.838081 4.533660 4.587350 4.313170 4.358330 4.424750 ## [127] 4.803090 7.139540 9.071560 9.337890 9.629480 9.318650 10.515000 ## [134] 9.964780 11.282600 10.048000 10.303900 11.186500 10.948100 9.480070 ## [141] 8.809490 8.579200 8.531470 9.635170 9.138650 9.447680 8.802510 ## [148] 9.611150 9.787400 9.432920 8.768380 8.822690 9.401530 9.579060 ## [155] 14.321988 13.170802 12.511922 10.561964 9.652961 8.523713 7.645318 ## [162] 7.462763 7.544005 7.347211 7.537033 7.310795 7.341749 7.476305 ## [169] 7.421047 7.381802 7.398633 7.934676 8.815771 9.335244 10.760830 ## [176] 11.400979 11.250975 12.138173 12.768363 12.735964 12.427341 12.086503 ## [183] 13.644940 14.713456 15.641560 16.972044 17.678566 17.798798 18.278828 ## [190] NA 16.269317 15.259672 14.197484 14.270182 14.714715 13.955317 ## [197] 13.719997 13.917566 16.450386 20.130244 21.488213 21.169039 20.821857 ## [204] 18.802373 16.951176 15.031508 13.885433 13.419708 13.391310 13.438673 ## [211] 12.997013 12.731380 13.096725 12.781592 12.687495 11.733670 11.623405 ## [218] 12.029799 12.674604 13.561877 15.560322 16.826027 17.238919 16.435055 ## [225] 16.156588 16.386247 15.994739 15.808491 15.335339 15.501906 15.750462 ## [232] 15.813097 15.818069 15.763004 15.763415 15.848448 15.543236 15.343314 ## [239] 15.133554 14.878146 NA 20.122789 NA 21.543915 20.494810 ## [246] 20.208873 20.149571 19.043943 17.930155 16.835701 17.243781 17.922027 ## [253] 17.457315 15.637815 15.053572 15.151438 14.823894 14.666839 14.135732 ## [260] 13.915358 14.326561 14.778377 15.763145 16.940269 17.786186 18.217911 ## [267] 17.992235 18.166406 19.032422 19.143826 18.636600 18.702145 18.130120 ## [274] 18.365359 18.074177 18.062602 18.280654 18.331464 17.700223 17.002926 ## [281] 17.245358 17.465165 17.076685 16.854514 16.893483 16.955922 16.795793 ## [288] 16.874876 16.822462 16.450231 16.734635 16.486585 5.704334 5.306090 ## [295] NA 5.350935 5.207219 5.303574 5.609634 6.246534 6.315260 ## [302] 6.913474 7.164375 7.701242 7.572774 6.123106 6.953925 6.500808 ## [309] 9.940868 7.538145 11.425805 9.094246 12.094420 12.084451 12.244675 ## [316] 12.116512 12.069895 12.102366 11.977507 11.889317 11.935524 10.761811 ## [323] 11.463138 7.890573 11.445759 11.556214 The problem with doing this is that our mean temperature values no longer have any context! They come from multiple cores, but this is not reflected without the other columns. Nevertheless, many R functions outside of the tidyverse require input as vectors (including many you’ve used so far, including mean(), max(), min(), etc.), and you will often see the $ used in code written in other places to refer to columns. Functions in the tidyverse allow you to refer to columns by name (without the $) when used within specific functions (summarise() is a good example), so you should do this whenever you can! 2.12 Base R Subsetting vs. select() and filter() In the wild, there are many ways to select columns and filter rows. I highly reccomend using filter() and select() to do this when writing new code, but you may see R code that subsets a data frame using square brackets in the form my_data_frame[c(&quot;column_name_1&quot;, &quot;column_name_2&quot;)] or my_data_frame[my_data_frame$column_name_1 &gt; some_number, c(&quot;column_name_1&quot;, &quot;column_name_2&quot;)]. The latter is equivalent to my_data_frame %&gt;% select(column_name_1, column_name_2) %&gt;% filter(column_name_1 &gt; some_number). The tidyverse method of subsetting I find to be much more clear and far less error-prone, but it’s worth knowing the other form so you can read R code written by others! 2.13 Summary In this tutorial we introduced the use of select(), filter(), arrange(), distinct(), and the pipe (%&gt;%). We also used group_by() and summarise() to provide summary statistics from a data frame. These functions are the building blocks of other powerful tools in the tidyverse. For more information, see the Data transformation chapter in R for Data Science. Another good resource is the tidyverse, visualization, and manipulation basics tutorial from Garrett Grolemund. References "],
["creating-visualizations-using-ggplot.html", "Tutorial 3 Creating Visualizations using ggplot 3.1 Prerequisites 3.2 Using ggplot 3.3 Aesthetics 3.4 Geometries 3.5 Facets 3.6 Make it look pretty 3.7 Summary", " Tutorial 3 Creating Visualizations using ggplot Intro For more information, see the data visualization chapter in R for Data Science. 3.1 Prerequisites The prerequisite for this tutorial is the tidyverse package. If this package isn’t installed, you’ll have to install it using install.packages(). install.packages(&quot;tidyverse&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) Finally, you will need to load the example data. For now, copy and paste the following code to load the Halifax geochemistry dataset (we will learn how to read various types of files into R in the preparing and loading data tutorial). halifax_geochem &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/halifax_geochem.csv&quot;, col_types = cols(.default = col_guess()) ) It’s worth mentioning a little bit about what this data frame contains, since we’ll be working with it for the rest of this tutorial. The data contains several bulk geochemical parameters from a recent study of Halifax drinking water reservoirs (Dunnington et al. 2018), including Pockwock Lake, Lake Major, Bennery Lake, Lake Fletcher, Lake Lemont, First Chain Lake, First Lake, and Second Lake. (Later, we will take a look at the core locations as well as the geochemical data). 3.2 Using ggplot The Grammar of Graphics (the “gg” in “ggplot”) is a way of describing a graphic that is derived from data, which in R is done using the ggplot() function and its many friends. Unlike other plotting functions, ggplot() builds graphics from the data up (rather than starting with a template of a graphic and working backward). We will start with an example: What the structure of the ggplot() call is Steps for plotting: Envision how you want your plot to look (draw it on paper if you have to!) Setup the data (select(), filter()) Setup your mapping (aes()) Choose your geoms (geom_*()) Make it look pretty 3.3 Aesthetics Categorical/Grouping Variables get mapped to X, Y, Colour, Shape, Linetype Continuous Variables get mapped to X, Y, Colour, Size 3.4 Geometries 3.5 Facets A way to make multiple groups 3.6 Make it look pretty 3.6.1 Labels labs() function 3.6.2 Scales scale_*_discrete(), scale_*_continuous() 3.7 Summary Tutorial summary For more information, see the data visualization chapter in R for Data Science. References "],
["prepare-load.html", "Tutorial 4 Preparing and Loading Data 4.1 Prerequisites 4.2 Preparing data 4.3 Loading data 4.4 Cleaning data 4.5 Summary", " Tutorial 4 Preparing and Loading Data Intro Draws from data transformation and data import from R for Data Science. 4.1 Prerequisites The prerequisites for this tutorial are tidyverse. If this package isn’t installed, you’ll have to install it using install.packages(). install.packages(&quot;tidyverse&quot;) Load the package when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) Finally, you will need to obtain the example data. In this tutorial, we will use Lake Arnold diatom counts (Whitehead et al. 1989), obtained from the Neotoma database. You will need to download the tidy CSV version of the data, and the Excel version of the data. 4.2 Preparing data Data comes in a nearly infinite variety of formats and configurations. Occasionally, you are in charge of entering data yourself, in which case you can plan ahead on how your data looks. 4.3 Loading data 4.4 Cleaning data 4.5 Summary Tutorial summary Draws from data transformation and data import from R for Data Science. References "],
["strat-diagrams.html", "Tutorial 5 Creating Strat diagraoms 5.1 Prerequisites 5.2 Data preparation 5.3 Using ggplot 5.4 Using analogue::stratiplot 5.5 Using rioja::strat.plot 5.6 Summary", " Tutorial 5 Creating Strat diagraoms Intro 5.1 Prerequisites The prerequisites for this tutorial are the tidyverse package, the analogue package, and the rioja package. If you haven’t installed the analogue and rioja packages yet, you’ll have to install them using install.packages(). install.packages(c(&quot;rioja&quot;, &quot;analogue&quot;)) Load the tidyverse when you’re done! We will load the other packages when we use functions that require them below. library(tidyverse) Finally, you will need to obtain the example data. In this tutorial, we will use the Lake Arnold diatom counts tidy CSV version of the data (Whitehead et al. 1989), and the Halifax geochemistry data. If you have these files downloaded you can load them yourself (see Tutorial 4), or you can copy/paste the following code to load the two datasets. halifax_geochem &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/halifax_geochem.csv&quot;, col_types = cols(.default = col_guess()) ) arnold_counts &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/lake_arnold_valve_counts_tidy.csv&quot;, col_types = cols(.default = col_guess()) ) 5.2 Data preparation TODO: How to rename columns so that they look pretty, how to use gather() and spread() to get data in the right form for the various functions. 5.3 Using ggplot 5.3.1 Single core halifax_geochem %&gt;% filter(core_id == &quot;POC15-2&quot;) %&gt;% gather(-core_id, -depth_cm, -age_ad, key = param, value = value) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() ## Warning: Removed 1 rows containing missing values (geom_path). ## Warning: Removed 10 rows containing missing values (geom_point). 5.3.2 Multiple cores Use colour aesthetic, age on y axis halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(-core_id, -depth_cm, -age_ad, key = param, value = value) %&gt;% ggplot(aes(y = age_ad, x = value, colour = core_id)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) ## Warning: Removed 2 rows containing missing values (geom_path). ## Warning: Removed 14 rows containing missing values (geom_point). Use facet_grid, age or depth on y-axis halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(-core_id, -depth_cm, -age_ad, key = param, value = value) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_grid(core_id~param, scales = &quot;free_x&quot;) + scale_y_reverse() ## Warning: Removed 1 rows containing missing values (geom_path). ## Warning: Removed 14 rows containing missing values (geom_point). 5.3.3 Species data arnold_counts_long &lt;- arnold_counts %&gt;% gather(-age_bp, -depth_cm, key = taxon, value = valve_count) %&gt;% group_by(depth_cm) %&gt;% mutate(relative_abundance = valve_count / sum(valve_count) * 100) %&gt;% ungroup() %&gt;% group_by(taxon) %&gt;% filter(max(relative_abundance) &gt; 20) %&gt;% ungroup() p &lt;- ggplot(arnold_counts_long, aes(y = depth_cm, x = relative_abundance)) + geom_segment(aes(xend = 0, yend = depth_cm)) + geom_path() + facet_grid(~taxon, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + scale_y_reverse() + scale_x_continuous(breaks = c(0, 5, 10, 15, 20, 25, 30)) + theme_minimal() + theme( strip.text.x = element_text(angle = 45, hjust = 0, vjust = 0) ) # gt &lt;- ggplot_gtable(ggplot_build(p)) # gt$layout$clip[gt$layout$name==&quot;panel-1-1&quot;] = &quot;off&quot; # grid::grid.draw(gt) p 5.4 Using analogue::stratiplot 5.5 Using rioja::strat.plot 5.6 Summary Tutorial summary References "],
["references.html", "References", " References "]
]
