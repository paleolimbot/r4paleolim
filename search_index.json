[
["index.html", "R for Paleolimnology Introduction 0.1 Prerequisites 0.2 Other places to learn R/RStudio/tidyverse 0.3 Colophon", " R for Paleolimnology Brent Thorne and Dewey Dunnington 2018-05-10 Introduction This is the website for the “R for Paleolimnology” workshop given at the Quebec-Ontario Paleolimnology Symposium (PALS) 2018. Here you will find an expanded version of the given workshop where you will lern how to conduct data science in R with an emphasis on Paleolimnology. You will learn and be able to work on a wide variety of skill sets in R including: how to get your data into R, how to structure your data, how to transform your data, and most importantly, how to visualize your paleolimnological data! By the end of this book we hope that you can take you passion for Paleolimnology and make data analysis enjoyable! No really, it can be enjoyable once you develop these skillsets! 0.1 Prerequisites R, RStudio, tidyverse 0.1.1 Installing R and RStudio Please download both R and RStudio, links below will direct you to the download page, just selesct the appropriate download for your operating system and follow the instructions given! R RStudio 0.2 Other places to learn R/RStudio/tidyverse The book “R for Data Science” (Grolemund and Wickham 2017) (free online version at http://r4ds.had.co.nz/index.html) The Introduction to the tidyverse Data Camp course by David Robinson. tidyverse, visualization, and manipulation basics tutorial from Garrett Grolemund 0.3 Colophon This course material was written using the bookdown package inside RStudio. Pages were built using Travis CI, pandoc and gitbook. The source is available on github. These tutorials were built with: devtools::session_info(pkgs = c(&quot;tidyverse&quot;)) ## Session info ------------------------------------------------------------- ## setting value ## version R version 3.5.0 (2017-01-27) ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## tz UTC ## date 2018-05-10 ## Packages ----------------------------------------------------------------- ## package * version date source ## assertthat 0.2.0 2017-04-11 cran (@0.2.0) ## backports 1.1.2 2017-12-13 cran (@1.1.2) ## base64enc 0.1-3 2015-07-28 cran (@0.1-3) ## BH 1.66.0-1 2018-02-13 cran (@1.66.0-) ## bindr 0.1.1 2018-03-13 cran (@0.1.1) ## bindrcpp 0.2.2 2018-03-29 cran (@0.2.2) ## broom 0.4.4 2018-03-29 cran (@0.4.4) ## callr 2.0.3 2018-04-11 cran (@2.0.3) ## cellranger 1.1.0 2016-07-27 cran (@1.1.0) ## cli 1.0.0 2017-11-05 cran (@1.0.0) ## colorspace 1.3-2 2016-12-14 cran (@1.3-2) ## compiler 3.5.0 2018-04-23 local ## crayon 1.3.4 2017-09-16 cran (@1.3.4) ## curl 3.2 2018-03-28 CRAN (R 3.5.0) ## DBI 0.8 2018-03-02 cran (@0.8) ## dbplyr 1.2.1 2018-02-19 cran (@1.2.1) ## debugme 1.1.0 2017-10-22 cran (@1.1.0) ## dichromat 2.0-0 2013-01-24 cran (@2.0-0) ## digest 0.6.15 2018-01-28 CRAN (R 3.5.0) ## dplyr 0.7.4 2017-09-28 cran (@0.7.4) ## evaluate 0.10.1 2017-06-24 cran (@0.10.1) ## forcats 0.3.0 2018-02-19 cran (@0.3.0) ## foreign 0.8-70 2017-11-28 CRAN (R 3.5.0) ## ggplot2 2.2.1 2016-12-30 cran (@2.2.1) ## glue 1.2.0 2017-10-29 cran (@1.2.0) ## graphics * 3.5.0 2018-04-23 local ## grDevices * 3.5.0 2018-04-23 local ## grid 3.5.0 2018-04-23 local ## gtable 0.2.0 2016-02-26 cran (@0.2.0) ## haven 1.1.1 2018-01-18 cran (@1.1.1) ## highr 0.6 2016-05-09 cran (@0.6) ## hms 0.4.2 2018-03-10 cran (@0.4.2) ## htmltools 0.3.6 2017-04-28 cran (@0.3.6) ## httr 1.3.1 2017-08-20 CRAN (R 3.5.0) ## jsonlite 1.5 2017-06-01 CRAN (R 3.5.0) ## knitr 1.20 2018-02-20 cran (@1.20) ## labeling 0.3 2014-08-23 cran (@0.3) ## lattice 0.20-35 2017-03-25 CRAN (R 3.5.0) ## lazyeval 0.2.1 2017-10-29 cran (@0.2.1) ## lubridate 1.7.4 2018-04-11 cran (@1.7.4) ## magrittr 1.5 2014-11-22 cran (@1.5) ## markdown 0.8 2017-04-20 cran (@0.8) ## MASS 7.3-49 2018-02-23 CRAN (R 3.5.0) ## methods * 3.5.0 2018-04-23 local ## mime 0.5 2016-07-07 CRAN (R 3.5.0) ## mnormt 1.5-5 2016-10-15 cran (@1.5-5) ## modelr 0.1.1 2017-07-24 cran (@0.1.1) ## munsell 0.4.3 2016-02-13 cran (@0.4.3) ## nlme 3.1-137 2018-04-07 CRAN (R 3.5.0) ## openssl 1.0.1 2018-03-03 CRAN (R 3.5.0) ## parallel 3.5.0 2018-04-23 local ## pillar 1.2.2 2018-04-26 cran (@1.2.2) ## pkgconfig 2.0.1 2017-03-21 cran (@2.0.1) ## plogr 0.2.0 2018-03-25 cran (@0.2.0) ## plyr 1.8.4 2016-06-08 cran (@1.8.4) ## praise 1.0.0 2015-08-11 cran (@1.0.0) ## psych 1.8.3.3 2018-03-30 cran (@1.8.3.3) ## purrr 0.2.4 2017-10-18 cran (@0.2.4) ## R6 2.2.2 2017-06-17 CRAN (R 3.5.0) ## RColorBrewer 1.1-2 2014-12-07 cran (@1.1-2) ## Rcpp 0.12.16 2018-03-13 cran (@0.12.16) ## readr 1.1.1 2017-05-16 cran (@1.1.1) ## readxl 1.1.0 2018-04-20 cran (@1.1.0) ## rematch 1.0.1 2016-04-21 cran (@1.0.1) ## reprex 0.1.2 2018-01-26 cran (@0.1.2) ## reshape2 1.4.3 2017-12-11 cran (@1.4.3) ## rlang 0.2.0 2018-02-20 cran (@0.2.0) ## rmarkdown 1.9 2018-03-01 cran (@1.9) ## rprojroot 1.3-2 2018-01-03 cran (@1.3-2) ## rstudioapi 0.7 2017-09-07 CRAN (R 3.5.0) ## rvest 0.3.2 2016-06-17 cran (@0.3.2) ## scales 0.5.0 2017-08-24 cran (@0.5.0) ## selectr 0.4-1 2018-04-06 cran (@0.4-1) ## stats * 3.5.0 2018-04-23 local ## stringi 1.1.7 2018-03-12 cran (@1.1.7) ## stringr 1.3.0 2018-02-19 cran (@1.3.0) ## testthat 2.0.0 2017-12-13 cran (@2.0.0) ## tibble 1.4.2 2018-01-22 cran (@1.4.2) ## tidyr 0.8.0 2018-01-29 cran (@0.8.0) ## tidyselect 0.2.4 2018-02-26 cran (@0.2.4) ## tidyverse 1.2.1 2017-11-14 cran (@1.2.1) ## tools 3.5.0 2018-04-23 local ## utf8 1.1.3 2018-01-03 cran (@1.1.3) ## utils * 3.5.0 2018-04-23 local ## viridisLite 0.3.0 2018-02-01 cran (@0.3.0) ## whisker 0.3-2 2013-04-28 CRAN (R 3.5.0) ## withr 2.1.2 2018-03-15 CRAN (R 3.5.0) ## xml2 1.2.0 2018-01-24 cran (@1.2.0) ## yaml 2.1.19 2018-05-01 cran (@2.1.19) References "],
["basic-r.html", "Tutorial 1 Basic R 1.1 Prerequisites 1.2 Expressions and Variables 1.3 Functions 1.4 Vectors 1.5 Indexing 1.6 Missing Values 1.7 Data Frames 1.8 Loading Packages 1.9 Using the Script Editor 1.10 The Environment 1.11 Excercises 1.12 Summary", " Tutorial 1 Basic R When you open RStudio, you are presented with the ominous &gt; of the R console. By the end of this tutorial, hopefully that &gt; should fill you with a feeling of hope and opportunity, for magical things can happen when you type the right thing after the &gt;. This short introduction will get you started with the R console so that when we introduce more powerful functions, you can understand what R is doing at the base level! The tutorial is loosely based on the Workflow: basics tutorial in the free online book, R for Data Science (Grolemund and Wickham 2017). The basic R console. 1.1 Prerequisites The prerequisite for this tutorial is the tidyverse package. If this package isn’t installed, you’ll have to install it using install.packages(), which you can type after the &gt;. install.packages(&quot;tidyverse&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) ## ── Attaching packages ────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 2.2.1 ✔ purrr 0.2.4 ## ✔ tibble 1.4.2 ✔ dplyr 0.7.4 ## ✔ tidyr 0.8.0 ✔ stringr 1.3.0 ## ✔ readr 1.1.1 ✔ forcats 0.3.0 ## ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 1.2 Expressions and Variables Let’s start with the basics. Try typing in something like this at the prompt: 1 + 1 ## [1] 2 2 * 5 ## [1] 10 5 ^ 2 ## [1] 25 2 * (5 + 1) ## [1] 12 As you can see, R works just like a calculator and evaluates all of these expressions just like you would expect. If we would like to save the result of one of these expressions we can assign that value to a variable like this: x &lt;- 1 + 1 Then, to view the value of x we can just type x at the console, and R will show us the value. x ## [1] 2 The &lt;- means “assign the value on the right to the variable on the left”. We can also use x in any expression and R will substitute its value in like this: x + 2 ## [1] 4 An expression is something that R can evaluate to produce a value, like 2+2 or x + 2. Any time you type this in the console without assigning it to a variable, R will print out the value. In fact, any time you type anything into the R console, R is evaluating that expression, which may or may not return a value. If there is no value returned, R won’t print anything when you press enter. So far we’ve just used numbers, but often we need to enter text into R. Whenever we do this, we surround the text in quotes, like this: mytext &lt;- &quot;I am text&quot; Text (called character vectors) are one of many data types available in R. 1.3 Functions A function is some kind of operation that takes one or more arguments (input values) and produces a return value (output value). The sqrt() function is a good example: sqrt(4) ## [1] 2 Here, 4 is an argument, and the function returns the square root of that, which is 2. Functions can take more arguments, like the max function: max(2, 6, 7, 2, 10) ## [1] 10 Here we are giving the max function 5 arguments, of which it returns the maximum. One other way we specify arguments is by keyword arguments, like in the paste function. paste(&quot;string1&quot;, &quot;string2&quot;, sep = &quot;_&quot;) ## [1] &quot;string1_string2&quot; The paste function takes its arguments and combines them using the sep that we specify, in this case &quot;_&quot;. The function returns this string. Many functions in R have many many arguments and usually we only want to modify one or two of interest to us. The format is always key=value, where key is the name of the keyword and value is some expression we would like to use as the value for that argument. R contains thousands of functions that do most of what you could possibly imagine with regards to data and statistics, but remembering which one you want and how to use it can be difficult. Luckily, RStudio makes it easy using tab autocompletion and easy access to help files. To autocomplete, start typing the name of the function and press the [Tab] key (or Ctrl+Space), and RStudio will helpfully provide you with suggestions. To access the documentation for a particular function, you can type ? in front of the function name and press return, and RStudio will open the help file for you if it exists. ?paste Will bring up the following: 1.3 Description Concatenate vectors after converting to character. 1.3 Usage paste (..., sep = &quot; &quot;, collapse = NULL) paste0(..., collapse = NULL) 1.3 Arguments … one or more R objects, to be converted to character vectors. sep a character string to separate the terms. Not NA_character_. collapse an optional character string to separate the results. Not NA_character_. Note that each of these arguments can be specified by keyword, and have default values that we can see in the usage section. The ... means that we can pass any number of arguments to the function. There’s too many functions in R to keep in your head at one time, so getting good at reading these help files is very useful! 1.4 Vectors So far we’ve just been dealing with single values like 2+2 or &quot;mystring&quot;, but the real power of R is that it can operate easily on large lists of data, so it makes sense that it provides us with an easy way to work with this data. These lists of data are called vectors, and we create them using the c function (c stands for concatenate, or join together). myvector &lt;- c(10, 9, 8, 7, 2) myvector ## [1] 10 9 8 7 2 Here the c function took our arguments of 10, 9, 8, 7, and 2, and returned a vector, which we assigned to the variable named myvector. When we evaluated myvector, it printed out the list of values it contained. Vectors don’t just have to contain numbers, they can contain strings as well. mytextvector &lt;- c(&quot;word1&quot;, &quot;word2&quot;, &quot;word3&quot;) mytextvector ## [1] &quot;word1&quot; &quot;word2&quot; &quot;word3&quot; Here the c function took our arguments and returned a vector of strings, which we assigned to the variable mytextvector. It is common to have to generate a vector of all the integer values between two numbers, so R provides a short form for this: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 20:12 ## [1] 20 19 18 17 16 15 14 13 12 myothervector &lt;- 13:16 myothervector ## [1] 13 14 15 16 You can also use an expression on either side of the :, like this: (5^2):(3*10) ## [1] 25 26 27 28 29 30 start &lt;- 25 end &lt;- start + 5 start:end ## [1] 25 26 27 28 29 30 1.5 Indexing Now we’ve created vectors, but to get at what’s inside them we need to retrieve values using an index. We do this using square brackets like this: myvector &lt;- c(10, 9, 8, 7, 2) myvector[1] ## [1] 10 myvector[5] ## [1] 2 myvector[3] ## [1] 8 This code creates a vector, assigns it to the variable myvector, then retrieves the 1st, 5th, and 3rd value stored in that vector. If we would like multiple values from the vector, we can pass multiple values as indices, like this: myvector[c(1, 5, 3)] ## [1] 10 2 8 You’ll notice that the index that we’re using is actually a vector itself! I know, we’re using a vector to index a vector and it’s a little trippy, but it’s incredibly useful. You’ll remember that we can easily create vectors of sequential integers, which we can use to get a sequence of values from a vector by using it as an index. myvector[1:3] ## [1] 10 9 8 This would be equivalent to: myvector[c(1, 2, 3)] ## [1] 10 9 8 There is one other useful way to index a vector using a vector, which is to use a TRUE/FALSE vector. This is probably the most useful of the indexing methods, because it allows you to do things like: myvector[myvector &gt; 7] ## [1] 10 9 8 This works because myvector &gt; 7 is, itself, a TRUE/FALSE vector with the same length as myvector, indicating whether or not it is greater than 7 at any given position. myvector &gt; 7 ## [1] TRUE TRUE TRUE FALSE FALSE 1.6 Missing Values Missing values are represented in R using NA, or “not assigned”. The fact that R handles missing values is one of the best reasons to use R for data analysis, because missing values are common in real data. NA values are propogated by R functions, meaning that if you take the mean() of a vector containing a missing value, it will give you NA as the average! mean(c(NA, 1, 2, 3)) ## [1] NA This is rarely what you want, but is a good practice to explicitly handle missing values in your code, and R forces you to do this. To avoid getting an NA back, you can use na.rm = TRUE, an argument that is available in many R functions. mean(c(NA, 1, 2, 3), na.rm = TRUE) ## [1] 2 1.7 Data Frames The vast majority of data in R is kept in a tibble (often called a data frame), which is a collection of vectors of the same length. You can think of a tibble as a table, with each column in the table being of the same type (numeric, character, TRUE/FALSE, etc.). my_tibble &lt;- tibble( number = c(1, 2, 3), name = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), is_one = c(TRUE, FALSE, FALSE) ) my_tibble ## # A tibble: 3 x 3 ## number name is_one ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 one TRUE ## 2 2 two FALSE ## 3 3 three FALSE The syntax for creating a tibble is tibble(column_name = value). The above tibble has three columns (number, a numeric column, name, a character column, and is_one, a logical TRUE/FALSE column). You can get these values as vectors again using the $ operator, which allows you to extract a vector from a data frame. my_tibble$number ## [1] 1 2 3 my_tibble$name ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; my_tibble$is_one ## [1] TRUE FALSE FALSE You can think of tibbles as a collection of vectors (variables) having the same number of elements. The number of elements has to be equal for all columns, meaning the ith value of each vector forms an observation. Data in this form is very useful and is the subject of most of the following tutorials. 1.8 Loading Packages Basic R functionality is designed to provide basic functions to help with data analysis, but may add-ons are available and code you find online (including here, shortly) will often tell you to load a “package” using library(). This will be a call to the library() function in the form library(packagename), where packagename is the name of the package which contains the functions you are interested in using (all of the subsequent tutorials will use library(tidyverse), because the tidyverse package contains many useful functions that you will use on a regular basis. When you call library(packagename), it will make these functions available to you. Occasionally you will see something like packagename::function_name(), which is a method to use a function without making all of the functions in a package. This is equivalent to typing library(packagename) then function_name() on the next line. You can install packages using install.packages(&quot;packagename&quot;) (note the quotes around packagename!). For example, let’s install the tidyverse package now, since you’ll be using it in the rest of this series. install.pacakges(&quot;tidyverse&quot;) Then, load it using library(): library(tidyverse) Finally, we are ready to call a function from the package. The tidyverse package actually installs and loads a family of useful packages for us, a list of which we can access using tidyverse_packages(). Try it! tidyverse_packages() ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; 1.9 Using the Script Editor In reality, very little of the code you type will be directly in the prompt. Instead, you will use RStudio’s script editor to run commands so that you can go back and edit them or run them from the beginning. To create a new R script, choose File, New File, and R script (you can also choose the little green “+” button at the top left of the console window). A blank R script should appear in a new tab. A new R script in the RStudio script editor. When you type a command in the editor and press enter, nothing happens! This is because the editor is meant to build script that contain multiple lines, unlike the console, which is meant to execute a single line at a time. To run a command you have typed in the script editor, press Ctrl+Enter (Command+Enter on a Mac). You can even select multiple lines, press Ctrl+Enter, and they will all run at once! You can also save the script and choose Source to run the whole thing. It is good practice to keep all of your code in a script somewhere. Typing it on a console repeatedly is hard work, and leads to errors! 1.10 The Environment When you’ve assigned a bunch of variables, it can be tricky to keep track of which ones are where and contain what! Hopefully you have given them short but descriptive names, but if you happen to forget you can check the “Environment” tab in RStudio (in the upper right part of the window). If you’d like to start fresh you can clear the environment (use the little broom icon or go to Session/Clear Workspace), and if you really want to start fresh, you can restart R using Session/Restart R. This will clear your workspace and unload all the packages you loaded using library(). This is a good way to make sure all of your analysis has been encapsulated by the script, since you can Restart R and Source your script to replicate your work. The RStudio Environment Tab By default, R will save your session when you quit and reload the variables you had previously assigned when you reopen it. This is dangerous, because even though you created an object, you may not be able to create it again! I highly reccomend using the script editor to encapsulate all of your code, and disable the automatic loading/saving of your workspace. You can do this in RStuio’s Preferences (or “Global Options” on Windows/Linux) by setting “Save workspace on exit” to “Never”, and unchecking “Restore .RData into workspace at startup”. The RStudio Global Options/Preferences window. 1.11 Excercises To practice the basics of R, complete the very first swirl module, R Programming / Basic Building Blocks. To do this, you’ll need to install and load swirl by typing this at the R prompt: install.packages(&quot;swirl&quot;) library(swirl) swirl() You should get a friendly greeting that will prompt you to choose a course (you want number 1, “R Programming: The basics of programming in R”) and a module (you want number 1, “Basic Building Blocks”). I suggest stopping after the first module, as R for Data Science provides a more effective introduction to the language. 1.12 Summary In this lesson we covered expressions, variables, functions, vectors, and indexing, all of which will help you get the most out of the tutorials in this series. For more information, check out the Workflow: basics and Workflow: scripts tutorial in the free online book, R for Data Science. References "],
["work-with-tables.html", "Tutorial 2 Working with Tables using the Tidyverse 2.1 Prerequisites 2.2 Viewing a Data Frame 2.3 Selecting Columns 2.4 Filtering Rows 2.5 Selecting and Filtering 2.6 The Pipe (%&gt;%) 2.7 Arranging (sorting) A Data Frame 2.8 Distinct Values 2.9 Calculating columns using mutate() 2.10 Summarising A Data Frame 2.11 Extracting Columns 2.12 Base R Subsetting vs. select() and filter() 2.13 Summary", " Tutorial 2 Working with Tables using the Tidyverse In this tutorial we will introduce the tibble (also called a data frame), or the object type that R uses to store tables. Most of the data you will work with in R can be represented by a table (think an excel sheet), and one of the main advantages of using R is that the data frame is a powerful and intuitive interface for tabular data. In this tutorial we will use the tidyverse to manipulate and summarise tabular data. The tutorial is a companion to the Data transformation chapter in R for Data Science. 2.1 Prerequisites The prerequisite for this tutorial is the tidyverse package. If this package isn’t installed, you’ll have to install it using install.packages(). install.packages(&quot;tidyverse&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) Finally, you will need to load the example data. For now, copy and paste the following code to load the Halifax geochemistry dataset (we will learn how to read various types of files into R in the preparing and loading data tutorial). halifax_geochem &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/halifax_geochem.csv&quot;, col_types = cols(.default = col_guess()) ) It’s worth mentioning a little bit about what this data frame contains, since we’ll be working with it for the rest of this tutorial. The data contains several bulk geochemical parameters from a recent study of Halifax drinking water reservoirs (Dunnington et al. 2018), including Pockwock Lake, Lake Major, Bennery Lake, Lake Fletcher, Lake Lemont, First Chain Lake, First Lake, and Second Lake. (Later, we will take a look at the core locations as well as the geochemical data). 2.2 Viewing a Data Frame The variable we have just created (halifax_geochem) is a tibble, which is a table of values much like you would find in a spreadsheet (you will notice that we loaded it directly from an Excel spreadhseet). Each column in the tibble represents a variable (in this case, the core identifier, depth of the sample, age represented by that sample, and several geochemical parameters), and each row in the table represents an observation (in this case, a sample from a sediment core). In RStudio’s “Environment” tab (usually at the top right of the screen), you should see a variable called halifax_geochem in the list. You can inspect it by clicking on the variable name, after which a tab will appear displaying the contents of the variable you just loaded. Clicking the little arrow to the left of the name will display the structure of the data frame, including the column names and some sample values. You can also do both of these things using the R commands View() and glimpse(), respectively. Also useful is the head() function, which will display the first few rows of a data frame. View(halifax_geochem) # will display a graphic table browser glimpse(halifax_geochem) # will display a text summary of the object ## Observations: 326 ## Variables: 9 ## $ core_id &lt;chr&gt; &quot;BEN15-2&quot;, &quot;BEN15-2&quot;, &quot;BEN15-2&quot;, &quot;BEN15-2&quot;, &quot;BEN... ## $ depth_cm &lt;dbl&gt; 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5... ## $ age_ad &lt;dbl&gt; 2015.903, 2015.188, 2014.474, 2012.950, 2011.425... ## $ C_percent &lt;dbl&gt; 14.75718, 14.65701, 14.94983, 14.54558, 14.40408... ## $ `C/N` &lt;dbl&gt; 12.15765, 12.17829, 11.92338, 11.67900, 11.61200... ## $ d13C_permille &lt;dbl&gt; -30.24752, -30.31042, -30.35799, -30.33835, -30.... ## $ d15N_permille &lt;dbl&gt; 2.461962, 2.447662, 2.336219, 2.528572, 2.662515... ## $ K_percent &lt;dbl&gt; 1.0026000, 1.0857000, 0.9782000, 0.9423000, 1.07... ## $ Ti_percent &lt;dbl&gt; 0.1693000, 0.1823000, 0.1678000, 0.1664000, 0.18... head(halifax_geochem) # will display the first few rows of the data ## # A tibble: 6 x 9 ## core_id depth_cm age_ad C_percent `C/N` d13C_permille d15N_permille ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 0 2016. 14.8 12.2 -30.2 2.46 ## 2 BEN15-2 0.5 2015. 14.7 12.2 -30.3 2.45 ## 3 BEN15-2 1 2014. 14.9 11.9 -30.4 2.34 ## 4 BEN15-2 1.5 2013. 14.5 11.7 -30.3 2.53 ## 5 BEN15-2 2 2011. 14.4 11.6 -30.4 2.66 ## 6 BEN15-2 2.5 2010. 14.4 11.9 -30.3 2.48 ## # ... with 2 more variables: K_percent &lt;dbl&gt;, Ti_percent &lt;dbl&gt; 2.3 Selecting Columns One way to subset halifax_geochem is to subset by column, for which we will use the select() function. For example, we may only be interested in the stable isotope information, represented by the columns d13C_permille and d15N_permille. stable_isotope_data &lt;- select( halifax_geochem, core_id, depth_cm, age_ad, d13C_permille, d15N_permille ) The first argument to the select() function is the original data frame (in this case, halifax_geochem), and the remaining arguments are the names of the columns to be selected. To select the core_id, age_ad, Ti, and K columns, you would use the following R command: geochem_data &lt;- select(halifax_geochem, core_id, depth_cm, age_ad, Ti_percent, K_percent) Some column names in halifax_geochem contain characters that could be interpreted as an operation (e.g., C/N, which is the name of the column and not C divided by N). To select these columns, you will need to surround the column name in backticks: select(halifax_geochem, core_id, depth_cm, age_ad, `C/N`) 2.3.1 Excercises Use View(), glimpse(), and head() to preview the two data frames we just created. Do they have the columns you would expect? Use select() to select core_id, depth_cm, C/N, d13C, and d15N, and assign it to the variable cn_data. 2.4 Filtering Rows Another way to subset halifax_geochem is by filtering rows using column values, similar to the filter feature in Microsoft Excel. This is done using the filter() function. For example, we may only be interested in the core from Pockwock Lake. pockwock_data &lt;- filter(halifax_geochem, core_id == &quot;POC15-2&quot;) Just like select(), the first argument to filter() is the original data frame, and the subsequent arguments are the conditions that each row must satisfy in order to be included in the output. Column values are referred to by the column name (in the above example, core_id), so to include all rows where the value in the core_id column is POC15-2, we use core_id == &quot;POC15-2&quot;. Passing multiple conditions means each row must satisfy all of the conditions, such that to obtain the data from core POC15-2 where the depth in the core was 0 cm, we can use the following call to filter(): pockwock_surface_data &lt;- filter(halifax_geochem, core_id == &quot;POC15-2&quot;, depth_cm == 0) It is very important that there are two equals signs within filter()! The == operator tests for equality (e.g. (2 + 2) == 4), whereas the = operator assigns a value or passes a named argument to a function, which is not what you’re trying to do within filter(). Other common operators that are useful within filter are != (not equal to), &gt; (greater than), &lt; (less than), &gt;= (greater than or equal to), &lt;= (less than or equal to), and %in% (tests if the value is one of several values). Using these, we could find out which observations are representative of the era 1950 to present: data_recent &lt;- filter(halifax_geochem, age_ad &gt;= 1950) We could also find observations from multiple cores: pockwock_major_data &lt;- filter(halifax_geochem, core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) 2.4.1 Exercises Use View(), glimpse(), and head() to preview the data frames we just created. Do they have the rows you would expect? Use filter() to find observations from the core FCL16-1 with an age between 1900 and present, and assign it to a name of your choosing. Are there any observations with a C/N value greater than 20? (hint: you will have to surround C/N in backticks) 2.5 Selecting and Filtering Often we need to use both select() and filter() to obtain the desired subset of a data frame. To do this, we need to pass the result of select() to filter(), or the result of filter() to select. For example, we could create a data frame of recent (age greater than 1950) stable isotope measurements (you’ll recall that we selected stable isotope columns in the data frame stable_isotope_data): recent_stable_isotopes &lt;- filter(stable_isotope_data, age_ad &gt;= 1950) recent_stable_isotopes2 &lt;- select( data_recent, core_id, depth_cm, age_ad, d13C_permille, d15N_permille ) 2.5.1 Exercises Use View(), glimpse(), and/or head() to verify that recent_stable_isotopes and recent_stable_isotopes_2 are identical. 2.6 The Pipe (%&gt;%) There is an easier way! Instead of creating intermediary variables every time we want to subset a data frame using select() and filter(), we can use the pipe operator (%&gt;%) to pass the result of one function call to another. Thus, creating our recent_stable_isotopes data frame from above becomes one line with one variable assignment instead of two. recent_stable_isotopes_pipe &lt;- halifax_geochem %&gt;% filter(age_ad &gt;= 1950) %&gt;% select(core_id, depth_cm, age_ad, d13C_permille, d15N_permille) What %&gt;% does is pass the left side into the first argument of the function call on the right side. Thus, filter(halifax_geochem, age_ad &gt;= 1950) becomes halifax_geochem %&gt;% filter(age_ad &gt;= 1950). When using the tidyverse family of packages, you should use the pipe as often as possible! It usually makes for more readable, less error-prone code, and reduces the number of temporary variables you create that clutter up your workspace. When using filter() and select() with other tidyverse manipulations like arrange(), group_by(), summarise(), and mutate(), the pipe becomes indispensable. 2.6.1 Exercises Inspect recent_stable_isotopes_pipe to ensure it is identical to recent_stable_isotopes. Create a data frame of stable isotope data from surface samples (depth_cm == 0) using halifax_geochem, filter(), select(), and %&gt;% and assign it to a variable of a suitable name. 2.7 Arranging (sorting) A Data Frame Sometimes it is desirable to view rows in a particular order, which can be used to quickly determine min and max values of various parameters. You can do this in the interactive editor using View(), but sometimes rows need to be in particular order for plotting or other analysis. This is done using the arrange() function. For example, it may make sense to view halifax_geochem in ascending core_id and depth_cm order (most recent first): halifax_geochem %&gt;% arrange(core_id, depth_cm) ## # A tibble: 326 x 9 ## core_id depth_cm age_ad C_percent `C/N` d13C_permille d15N_permille ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 0 2016. 14.8 12.2 -30.2 2.46 ## 2 BEN15-2 0.5 2015. 14.7 12.2 -30.3 2.45 ## 3 BEN15-2 1 2014. 14.9 11.9 -30.4 2.34 ## 4 BEN15-2 1.5 2013. 14.5 11.7 -30.3 2.53 ## 5 BEN15-2 2 2011. 14.4 11.6 -30.4 2.66 ## 6 BEN15-2 2.5 2010. 14.4 11.9 -30.3 2.48 ## 7 BEN15-2 3 2008. 14.4 11.9 -30.3 2.53 ## 8 BEN15-2 3.5 2005. 14.3 12.0 -30.2 2.60 ## 9 BEN15-2 4 2002. 14.0 12.0 -30.2 2.60 ## 10 BEN15-2 4.5 1999. 13.7 12.1 -30.2 2.48 ## # ... with 316 more rows, and 2 more variables: K_percent &lt;dbl&gt;, ## # Ti_percent &lt;dbl&gt; Or descending depth order (most recent last): halifax_geochem %&gt;% arrange(core_id, desc(depth_cm)) ## # A tibble: 326 x 9 ## core_id depth_cm age_ad C_percent `C/N` d13C_permille d15N_permille ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 29 1742. 14.5 13.4 -29.3 3.54 ## 2 BEN15-2 28 1751. 14.5 13.5 -29.3 3.60 ## 3 BEN15-2 27 1759. 15.1 13.4 -29.4 3.60 ## 4 BEN15-2 26 1768. 15.9 13.5 -29.5 3.57 ## 5 BEN15-2 25 1776. 16.7 13.4 -29.6 3.42 ## 6 BEN15-2 24 1784. 16.8 13.4 -29.5 3.42 ## 7 BEN15-2 23 1793. 16.5 13.5 -29.4 3.39 ## 8 BEN15-2 22 1801. 17.2 13.4 -29.4 3.41 ## 9 BEN15-2 21 1810. 17.3 13.6 -29.4 3.22 ## 10 BEN15-2 20 1818. 17.6 13.5 -29.4 3.18 ## # ... with 316 more rows, and 2 more variables: K_percent &lt;dbl&gt;, ## # Ti_percent &lt;dbl&gt; The arrange() function takes columns as arguments, surrounded by desc() if that column should be sorted in descending order. 2.8 Distinct Values It is often useful to know which values exist in a data frame. For example, I’ve told you that the core locations are for various lakes in the halifax area, but what are they actually called in the dataset? To do this, we can use the distinct() function. halifax_geochem %&gt;% distinct(core_id) ## # A tibble: 8 x 1 ## core_id ## &lt;chr&gt; ## 1 BEN15-2 ## 2 FCL16-1 ## 3 FLE16-1 ## 4 FLK12-1 ## 5 LEM16-1 ## 6 MAJ15-1 ## 7 POC15-2 ## 8 SLK13-1 The distinct() function can take any number of column names as arguments, although in this particular dataset there isn’t a good example for this. 2.9 Calculating columns using mutate() To create a brand-new column, we can use the mutate() function. This creates a column in a way that we can use existing column names to calculate a new column. For example, we could convert the age_ad column to years before 1950: halifax_geochem %&gt;% mutate(age_bp = 1950 - age_ad) %&gt;% select(core_id, age_ad, age_bp) ## # A tibble: 326 x 3 ## core_id age_ad age_bp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 2016. -65.9 ## 2 BEN15-2 2015. -65.2 ## 3 BEN15-2 2014. -64.5 ## 4 BEN15-2 2013. -62.9 ## 5 BEN15-2 2011. -61.4 ## 6 BEN15-2 2010. -59.6 ## 7 BEN15-2 2008. -57.8 ## 8 BEN15-2 2005. -54.9 ## 9 BEN15-2 2002. -52.1 ## 10 BEN15-2 1999. -49.3 ## # ... with 316 more rows Or, we could convert the K_percent and Ti_percent columns to parts per million: halifax_geochem %&gt;% mutate( K_ppm = K_percent * 10000, Ti_ppm = Ti_percent * 10000 ) %&gt;% select(core_id, K_percent, K_ppm, Ti_percent, Ti_ppm) ## # A tibble: 326 x 5 ## core_id K_percent K_ppm Ti_percent Ti_ppm ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 1.00 10026 0.169 1693 ## 2 BEN15-2 1.09 10857. 0.182 1823 ## 3 BEN15-2 0.978 9782 0.168 1678 ## 4 BEN15-2 0.942 9423 0.166 1664 ## 5 BEN15-2 1.08 10784. 0.183 1832. ## 6 BEN15-2 1.09 10863 0.183 1830 ## 7 BEN15-2 1.04 10374. 0.176 1762 ## 8 BEN15-2 0.97 9700 0.167 1670 ## 9 BEN15-2 1.12 11175 0.179 1791 ## 10 BEN15-2 1.01 10064. 0.17 1700. ## # ... with 316 more rows 2.10 Summarising A Data Frame So far we have looked at subsets of halifax_geochem, but what if we want per-core averages instead of raw data values? Using the tidyverse, we can group_by() the core_id column, and summarise(): halifax_geochem %&gt;% group_by(core_id) %&gt;% summarise(mean_CN = mean(`C/N`)) ## # A tibble: 8 x 2 ## core_id mean_CN ## &lt;chr&gt; &lt;dbl&gt; ## 1 BEN15-2 12.8 ## 2 FCL16-1 14.2 ## 3 FLE16-1 12.4 ## 4 FLK12-1 12.8 ## 5 LEM16-1 12.6 ## 6 MAJ15-1 NA ## 7 POC15-2 NA ## 8 SLK13-1 NA Here group_by() gets a list of columns, for which each unique combination of values will get one row in the output. summarise() gets a list of expressions that are evaluated for every unique combination of values defined by group_by() (e.g., mean_CN is the mean() of the C/N column for each core). Often, we want to include a number of summary columns in the output, which we can do by pasing more expressions to summarise(): halifax_geochem %&gt;% group_by(core_id) %&gt;% summarise( mean_CN = mean(`C/N`), min_CN = min(`C/N`), max_CN = max(`C/N`), sd_CN = sd(`C/N`) ) ## # A tibble: 8 x 5 ## core_id mean_CN min_CN max_CN sd_CN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BEN15-2 12.8 11.6 13.6 0.648 ## 2 FCL16-1 14.2 12.1 16.5 1.05 ## 3 FLE16-1 12.4 10.5 13.3 0.830 ## 4 FLK12-1 12.8 10.6 14.9 1.02 ## 5 LEM16-1 12.6 11.8 13.1 0.307 ## 6 MAJ15-1 NA NA NA NA ## 7 POC15-2 NA NA NA NA ## 8 SLK13-1 NA NA NA NA You will notice that in for several cores the summary values are NA, or missing. This is because R propogates missing values unless you explicitly tell it not to. To fix this, you could replace mean(`C/N`) with mean(`C/N`, na.rm = TRUE). Other useful functions to use inside summarise() include mean(), median(), sd(), sum(), min(), and max(). These all take a vector of values and produce a single aggregate value suitable for use in summarise(). One special function, n(), you can use (with no arguments) inside summarise() to tell you how many observations were aggregated to produce the values in that row. halifax_geochem %&gt;% group_by(core_id) %&gt;% summarise( mean_CN = mean(`C/N`, na.rm = TRUE), min_CN = min(`C/N`, na.rm = TRUE), max_CN = max(`C/N`, na.rm = TRUE), sd_CN = sd(`C/N`, na.rm = TRUE), n = n() ) ## # A tibble: 8 x 6 ## core_id mean_CN min_CN max_CN sd_CN n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 BEN15-2 12.8 11.6 13.6 0.648 35 ## 2 FCL16-1 14.2 12.1 16.5 1.05 49 ## 3 FLE16-1 12.4 10.5 13.3 0.830 37 ## 4 FLK12-1 12.8 10.6 14.9 1.02 33 ## 5 LEM16-1 12.6 11.8 13.1 0.307 35 ## 6 MAJ15-1 15.7 14.3 18.4 1.09 51 ## 7 POC15-2 15.2 13.6 17.4 1.26 52 ## 8 SLK13-1 11.4 10.3 11.9 0.443 34 It’s always a good idea to include n() inside summarise(), if nothing else as a check to make sure you’ve used group_by() with the correct columns. 2.10.1 Excercises Assign the data frame we just created to a variable, and inspect it using View() and str(). Which cores have the most terrestrial C/N signature? Which cores have the most aquatic signature? Create a similar data frame to the one we just created but using C_percent. Which cores had the highest peak organic value. Which cores had the oldest estimated basal date? 2.11 Extracting Columns When we use select() or distinct(), we get back a data frame, however occasionally we need one or a few of the vectors that make up the data frame (recall from the last tutorial that data frames are a collection of column vectors). If we needed just the temperature values, we can use the $ operator or the pull() function to extract a column vector. halifax_geochem$C_percent ## [1] 14.757176 14.657012 14.949832 14.545579 14.404084 14.403361 14.417744 ## [8] 14.279836 14.013717 13.703397 13.403708 12.918529 12.905447 13.359170 ## [15] 13.852618 14.386124 14.533912 14.593866 15.667289 14.765232 15.028548 ## [22] 15.290797 16.107091 16.828205 17.336513 17.591619 17.311306 17.183589 ## [29] 16.492232 16.808112 16.701580 15.903060 15.069473 14.535988 14.529308 ## [36] 16.865924 15.026170 15.495396 14.920478 14.986076 15.500813 15.359202 ## [43] 15.174549 15.809170 15.493308 13.107648 14.348712 13.259158 13.556510 ## [50] 13.119736 12.610362 12.626289 13.510481 13.516503 13.673926 13.739241 ## [57] 13.319716 12.752857 12.449856 13.769313 13.594019 14.074802 15.168339 ## [64] 16.618788 16.359283 16.105118 16.514953 18.517095 17.978341 17.371192 ## [71] 16.311194 17.566880 17.477789 17.054982 17.685215 17.953537 19.507351 ## [78] 20.374763 20.849903 18.816935 19.815698 20.777122 20.852904 21.074918 ## [85] 6.263526 6.173985 6.054831 5.702408 5.113311 4.834282 4.572133 ## [92] 4.370639 4.433741 4.321790 4.511906 4.997175 5.026973 5.507729 ## [99] 5.613024 6.005021 6.368445 6.736808 7.413337 7.826077 8.387502 ## [106] 8.641869 9.651663 10.471288 11.024577 11.867441 9.647337 11.459685 ## [113] 11.809470 12.079710 11.911566 12.071773 12.279458 12.478523 12.579303 ## [120] 12.571033 12.838081 4.533660 4.587350 4.313170 4.358330 4.424750 ## [127] 4.803090 7.139540 9.071560 9.337890 9.629480 9.318650 10.515000 ## [134] 9.964780 11.282600 10.048000 10.303900 11.186500 10.948100 9.480070 ## [141] 8.809490 8.579200 8.531470 9.635170 9.138650 9.447680 8.802510 ## [148] 9.611150 9.787400 9.432920 8.768380 8.822690 9.401530 9.579060 ## [155] 14.321988 13.170802 12.511922 10.561964 9.652961 8.523713 7.645318 ## [162] 7.462763 7.544005 7.347211 7.537033 7.310795 7.341749 7.476305 ## [169] 7.421047 7.381802 7.398633 7.934676 8.815771 9.335244 10.760830 ## [176] 11.400979 11.250975 12.138173 12.768363 12.735964 12.427341 12.086503 ## [183] 13.644940 14.713456 15.641560 16.972044 17.678566 17.798798 18.278828 ## [190] NA 16.269317 15.259672 14.197484 14.270182 14.714715 13.955317 ## [197] 13.719997 13.917566 16.450386 20.130244 21.488213 21.169039 20.821857 ## [204] 18.802373 16.951176 15.031508 13.885433 13.419708 13.391310 13.438673 ## [211] 12.997013 12.731380 13.096725 12.781592 12.687495 11.733670 11.623405 ## [218] 12.029799 12.674604 13.561877 15.560322 16.826027 17.238919 16.435055 ## [225] 16.156588 16.386247 15.994739 15.808491 15.335339 15.501906 15.750462 ## [232] 15.813097 15.818069 15.763004 15.763415 15.848448 15.543236 15.343314 ## [239] 15.133554 14.878146 NA 20.122789 NA 21.543915 20.494810 ## [246] 20.208873 20.149571 19.043943 17.930155 16.835701 17.243781 17.922027 ## [253] 17.457315 15.637815 15.053572 15.151438 14.823894 14.666839 14.135732 ## [260] 13.915358 14.326561 14.778377 15.763145 16.940269 17.786186 18.217911 ## [267] 17.992235 18.166406 19.032422 19.143826 18.636600 18.702145 18.130120 ## [274] 18.365359 18.074177 18.062602 18.280654 18.331464 17.700223 17.002926 ## [281] 17.245358 17.465165 17.076685 16.854514 16.893483 16.955922 16.795793 ## [288] 16.874876 16.822462 16.450231 16.734635 16.486585 5.704334 5.306090 ## [295] NA 5.350935 5.207219 5.303574 5.609634 6.246534 6.315260 ## [302] 6.913474 7.164375 7.701242 7.572774 6.123106 6.953925 6.500808 ## [309] 9.940868 7.538145 11.425805 9.094246 12.094420 12.084451 12.244675 ## [316] 12.116512 12.069895 12.102366 11.977507 11.889317 11.935524 10.761811 ## [323] 11.463138 7.890573 11.445759 11.556214 halifax_geochem %&gt;% pull(C_percent) ## [1] 14.757176 14.657012 14.949832 14.545579 14.404084 14.403361 14.417744 ## [8] 14.279836 14.013717 13.703397 13.403708 12.918529 12.905447 13.359170 ## [15] 13.852618 14.386124 14.533912 14.593866 15.667289 14.765232 15.028548 ## [22] 15.290797 16.107091 16.828205 17.336513 17.591619 17.311306 17.183589 ## [29] 16.492232 16.808112 16.701580 15.903060 15.069473 14.535988 14.529308 ## [36] 16.865924 15.026170 15.495396 14.920478 14.986076 15.500813 15.359202 ## [43] 15.174549 15.809170 15.493308 13.107648 14.348712 13.259158 13.556510 ## [50] 13.119736 12.610362 12.626289 13.510481 13.516503 13.673926 13.739241 ## [57] 13.319716 12.752857 12.449856 13.769313 13.594019 14.074802 15.168339 ## [64] 16.618788 16.359283 16.105118 16.514953 18.517095 17.978341 17.371192 ## [71] 16.311194 17.566880 17.477789 17.054982 17.685215 17.953537 19.507351 ## [78] 20.374763 20.849903 18.816935 19.815698 20.777122 20.852904 21.074918 ## [85] 6.263526 6.173985 6.054831 5.702408 5.113311 4.834282 4.572133 ## [92] 4.370639 4.433741 4.321790 4.511906 4.997175 5.026973 5.507729 ## [99] 5.613024 6.005021 6.368445 6.736808 7.413337 7.826077 8.387502 ## [106] 8.641869 9.651663 10.471288 11.024577 11.867441 9.647337 11.459685 ## [113] 11.809470 12.079710 11.911566 12.071773 12.279458 12.478523 12.579303 ## [120] 12.571033 12.838081 4.533660 4.587350 4.313170 4.358330 4.424750 ## [127] 4.803090 7.139540 9.071560 9.337890 9.629480 9.318650 10.515000 ## [134] 9.964780 11.282600 10.048000 10.303900 11.186500 10.948100 9.480070 ## [141] 8.809490 8.579200 8.531470 9.635170 9.138650 9.447680 8.802510 ## [148] 9.611150 9.787400 9.432920 8.768380 8.822690 9.401530 9.579060 ## [155] 14.321988 13.170802 12.511922 10.561964 9.652961 8.523713 7.645318 ## [162] 7.462763 7.544005 7.347211 7.537033 7.310795 7.341749 7.476305 ## [169] 7.421047 7.381802 7.398633 7.934676 8.815771 9.335244 10.760830 ## [176] 11.400979 11.250975 12.138173 12.768363 12.735964 12.427341 12.086503 ## [183] 13.644940 14.713456 15.641560 16.972044 17.678566 17.798798 18.278828 ## [190] NA 16.269317 15.259672 14.197484 14.270182 14.714715 13.955317 ## [197] 13.719997 13.917566 16.450386 20.130244 21.488213 21.169039 20.821857 ## [204] 18.802373 16.951176 15.031508 13.885433 13.419708 13.391310 13.438673 ## [211] 12.997013 12.731380 13.096725 12.781592 12.687495 11.733670 11.623405 ## [218] 12.029799 12.674604 13.561877 15.560322 16.826027 17.238919 16.435055 ## [225] 16.156588 16.386247 15.994739 15.808491 15.335339 15.501906 15.750462 ## [232] 15.813097 15.818069 15.763004 15.763415 15.848448 15.543236 15.343314 ## [239] 15.133554 14.878146 NA 20.122789 NA 21.543915 20.494810 ## [246] 20.208873 20.149571 19.043943 17.930155 16.835701 17.243781 17.922027 ## [253] 17.457315 15.637815 15.053572 15.151438 14.823894 14.666839 14.135732 ## [260] 13.915358 14.326561 14.778377 15.763145 16.940269 17.786186 18.217911 ## [267] 17.992235 18.166406 19.032422 19.143826 18.636600 18.702145 18.130120 ## [274] 18.365359 18.074177 18.062602 18.280654 18.331464 17.700223 17.002926 ## [281] 17.245358 17.465165 17.076685 16.854514 16.893483 16.955922 16.795793 ## [288] 16.874876 16.822462 16.450231 16.734635 16.486585 5.704334 5.306090 ## [295] NA 5.350935 5.207219 5.303574 5.609634 6.246534 6.315260 ## [302] 6.913474 7.164375 7.701242 7.572774 6.123106 6.953925 6.500808 ## [309] 9.940868 7.538145 11.425805 9.094246 12.094420 12.084451 12.244675 ## [316] 12.116512 12.069895 12.102366 11.977507 11.889317 11.935524 10.761811 ## [323] 11.463138 7.890573 11.445759 11.556214 The problem with doing this is that our mean temperature values no longer have any context! They come from multiple cores, but this is not reflected without the other columns. Nevertheless, many R functions outside of the tidyverse require input as vectors (including many you’ve used so far, including mean(), max(), min(), etc.), and you will often see the $ used in code written in other places to refer to columns. Functions in the tidyverse allow you to refer to columns by name (without the $) when used within specific functions (summarise() is a good example), so you should do this whenever you can! 2.12 Base R Subsetting vs. select() and filter() In the wild, there are many ways to select columns and filter rows. I highly reccomend using filter() and select() to do this when writing new code, but you may see R code that subsets a data frame using square brackets in the form my_data_frame[c(&quot;column_name_1&quot;, &quot;column_name_2&quot;)] or my_data_frame[my_data_frame$column_name_1 &gt; some_number, c(&quot;column_name_1&quot;, &quot;column_name_2&quot;)]. The latter is equivalent to my_data_frame %&gt;% select(column_name_1, column_name_2) %&gt;% filter(column_name_1 &gt; some_number). The tidyverse method of subsetting I find to be much more clear and far less error-prone, but it’s worth knowing the other form so you can read R code written by others! 2.13 Summary In this tutorial we introduced the use of select(), filter(), arrange(), distinct(), and the pipe (%&gt;%). We also used group_by() and summarise() to provide summary statistics from a data frame. These functions are the building blocks of other powerful tools in the tidyverse. For more information, see the Data transformation chapter in R for Data Science. Another good resource is the tidyverse, visualization, and manipulation basics tutorial from Garrett Grolemund. References "],
["creating-visualizations-using-ggplot.html", "Tutorial 3 Creating Visualizations using ggplot 3.1 Prerequisites 3.2 Using ggplot 3.3 Aesthetics 3.4 Geometries 3.5 Facets 3.6 Make it look pretty 3.7 Summary", " Tutorial 3 Creating Visualizations using ggplot This tutorial will introduce you to using ggplot2 in order to visualize your data. R has many options for creating graphs and figures but, ggplot2 is versitile, firendly to learn, and quite elegant. Using ggplot2 you will be able to quickly learn the basics of it’s functionallity and apply those skills to more advanced figures as explained in Chapter 5. For more information, see the data visualization chapter in R for Data Science. 3.1 Prerequisites The prerequisite for this tutorial is the tidyverse package. If this package isn’t installed, you’ll have to install it using install.packages(). install.packages(&quot;tidyverse&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) Finally, you will need to load the example data. For now, copy and paste the following code to load the Halifax geochemistry dataset (we will learn how to read various types of files into R in the preparing and loading data tutorial). halifax_geochem &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/halifax_geochem.csv&quot;, col_types = cols(.default = col_guess()) ) It’s worth mentioning a little bit about what this data frame contains, since we’ll be working with it for the rest of this tutorial. The data contains several bulk geochemical parameters from a recent study of Halifax drinking water reservoirs (Dunnington et al. 2018), including Pockwock Lake, Lake Major, Bennery Lake, Lake Fletcher, Lake Lemont, First Chain Lake, First Lake, and Second Lake. (Later, we will take a look at the core locations as well as the geochemical data). 3.2 Using ggplot The Grammar of Graphics (the “gg” in “ggplot”) is a way of describing a graphic that is derived from data, which in R is done using the ggplot() function and its many friends. Unlike other plotting functions, ggplot() builds graphics from the data up (rather than starting with a template of a graphic and working backward). Before we can use ggplot functionality we need to use the skills learned in Chapter 2 where we filtered our data. See if you can use filter() on the halifax_geochem data to create the pockwock_data and pockwock_major_data variable (HINT: check out the Filtering Rows secontion in Chapter 2). pockwock_data &lt;- filter(halifax_geochem, core_id == &quot;POC15-2&quot;) pockwock_major_data &lt;- filter(halifax_geochem, core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) Now we can start with the ggplot example using the pockwock_major_data: ggplot(data = pockwock_major_data, mapping = aes(x = K_percent, y = Ti_percent)) + geom_point() ## Warning: Removed 1 rows containing missing values (geom_point). What the structure of the ggplot() call is Steps for plotting: Envision how you want your plot to look (draw it on paper if you have to!) Setup the data (select(), filter()) Setup your mapping (aes()) Choose your geoms (geom_*()) Make it look pretty 3.3 Aesthetics Categorical/Grouping Variables get mapped to X, Y, Colour, Shape, Linetype. Continuous Variables get mapped to X, Y, Colour, Size. For example, we can choose to colour the previous figure in order to visually see the difference between core samples by simply adding a colour = core_id argument to the aesthetic: ggplot(data = pockwock_major_data, mapping = aes(x = K_percent, y = Ti_percent, colour = core_id)) + geom_point() ## Warning: Removed 1 rows containing missing values (geom_point). Notice how there is a legend automatically generated for us? We will look into changeing the labelling of that later in this tutorial! We can also choose to categorize our data with shapes other than the points seen previously, since not all figures may be welcome if they have colour! ggplot(data = pockwock_major_data, mapping = aes(x = K_percent, y = Ti_percent, shape = core_id)) + geom_point() ## Warning: Removed 1 rows containing missing values (geom_point). Now we can try to provide some information on depth by making each symbols size relative to its depth value. For this example I only want to use the pockwock_data we previously created in Chapter 2: ggplot(data = pockwock_data, mapping = aes(x = K_percent, y = Ti_percent, size = depth_cm)) + geom_point() ## Warning: Removed 1 rows containing missing values (geom_point). 3.4 Geometries We can easily change the type of geometry being used in the ggplot we have been working on. Here is an example of the same figure as above only with geom_line instead of geom_point: ggplot(data = pockwock_major_data, mapping = aes(x = K_percent, y = Ti_percent, colour = core_id)) + geom_line() ## Warning: Removed 1 rows containing missing values (geom_path). Or we could choose multiple geometries! ggplot(data = pockwock_major_data, mapping = aes(x = K_percent, y = Ti_percent, colour = core_id)) + geom_line() + geom_point() ## Warning: Removed 1 rows containing missing values (geom_path). ## Warning: Removed 1 rows containing missing values (geom_point). 3.5 Facets An alternative to altering aesthetics of a plot to provide the end-user with visual seperation is to split your plot into facets, subplots that each display one subset of the data. We can do this simply by using the facet_wrap() argument. For this example we can use the origional halifax_geochem table and create one facet for each core! ggplot(data = halifax_geochem, mapping = aes(x = K_percent, y = Ti_percent)) + geom_line() + geom_point() + facet_wrap(~core_id) ## Warning: Removed 1 rows containing missing values (geom_path). ## Warning: Removed 7 rows containing missing values (geom_point). This is great, however we may wnat to change the layout of these facet plots. We can do this easily by specifying the number of rows nrow= or the number of columns ncol= within facet_wrap. ggplot(data = halifax_geochem, mapping = aes(x = K_percent, y = Ti_percent)) + geom_line() + geom_point() + facet_wrap(~core_id, ncol = 4) ## Warning: Removed 1 rows containing missing values (geom_path). ## Warning: Removed 7 rows containing missing values (geom_point). 3.6 Make it look pretty 3.6.1 Labels labs() function 3.6.2 Scales scale_*_discrete(), scale_*_continuous() 3.7 Summary Tutorial summary For more information, see the data visualization chapter in R for Data Science. References "],
["prepare-load.html", "Tutorial 4 Preparing and Loading Data 4.1 Prerequisites 4.2 Loading data 4.3 Transforming data 4.4 Exporing data 4.5 Summary", " Tutorial 4 Preparing and Loading Data Intro Draws from data transformation, tidy data and data import from R for Data Science (Grolemund and Wickham 2017). 4.1 Prerequisites The prerequisites for this tutorial are tidyverse. If this package isn’t installed, you’ll have to install it using install.packages(). install.packages(&quot;tidyverse&quot;) Load the package when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) Finally, you will need to obtain the example data. In this tutorial, we will use Lake Arnold diatom counts (Whitehead et al. 1989), obtained from the Neotoma database. You will need to download the tidy CSV version of the data, and the Excel version of the data. knitr::include_graphics(&quot;04-data-figs/arnold_excel_counts.png&quot;) Figure 4.1: Excel screenshot of the Lake Arnold data. The format of one row per taxon with one column per sample is one way that these data are organized in the wild. 4.2 Loading data If data are in a CSV, use read_csv(): arnold_counts_csv &lt;- read_csv(&quot;data/lake_arnold_valve_counts_tidy.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_integer() ## ) ## See spec(...) for full column specifications. The function will guess all the column types, which you can copy and paste into your read call like this: arnold_counts_csv &lt;- read_csv( &quot;data/lake_arnold_valve_counts_tidy.csv&quot;, col_types = cols( .default = col_integer() ) ) This will make sure that your column types are read properly in the future, and if any columns are guessed incorrectly, they can be fixed here. For more see the data import chapter of Grolemund and Wickham (2017). We will revisit the arnold_counts_csv data frame shortly. It contains the data in the form expected by many R functions, particularly for ordination/transfer function calculations, however it is more common to see the data in a form shown in Figure 4.1. If data are in an Excel sheet, we can use the readxl package. This package is installed with the tidyverse, but you need to load it explicitly to use the read_excel() function. library(readxl) arnold_counts_excel &lt;- read_excel( &quot;data/lake_arnold_valve_counts.xlsx&quot;, sheet = &quot;taxon counts&quot;, skip = 1 ) 4.3 Transforming data gather(): arnold_counts_excel %&gt;% gather(key = depth_cm, value = valve_count, -taxon) ## # A tibble: 2,128 x 3 ## taxon depth_cm valve_count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Achnanthes linearis fo. curta 0 NA ## 2 Achnanthes marginulata 0 8 ## 3 Achnanthes minutissima 0 NA ## 4 Achnanthes sp. 0 NA ## 5 Actinella punctata 0 3 ## 6 Anomoeoneis serians 0 5 ## 7 Anomoeoneis serians var. brachysira 0 3 ## 8 Anomoeoneis vitrea 0 NA ## 9 Caloneis ventricosa var. minuta 0 NA ## 10 Cocconeis sp. 0 NA ## # ... with 2,118 more rows Change type of depth column: arnold_counts_excel %&gt;% gather(key = depth_cm, value = valve_count, -taxon) %&gt;% mutate(depth_cm = as.numeric(depth_cm)) ## # A tibble: 2,128 x 3 ## taxon depth_cm valve_count ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Achnanthes linearis fo. curta 0 NA ## 2 Achnanthes marginulata 0 8 ## 3 Achnanthes minutissima 0 NA ## 4 Achnanthes sp. 0 NA ## 5 Actinella punctata 0 3 ## 6 Anomoeoneis serians 0 5 ## 7 Anomoeoneis serians var. brachysira 0 3 ## 8 Anomoeoneis vitrea 0 NA ## 9 Caloneis ventricosa var. minuta 0 NA ## 10 Cocconeis sp. 0 NA ## # ... with 2,118 more rows Change NA valve counts to 0: arnold_counts_excel %&gt;% gather(key = depth_cm, value = valve_count, -taxon) %&gt;% mutate(depth_cm = as.numeric(depth_cm)) %&gt;% mutate(valve_count = if_else(is.na(valve_count), 0, valve_count)) ## # A tibble: 2,128 x 3 ## taxon depth_cm valve_count ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Achnanthes linearis fo. curta 0 0 ## 2 Achnanthes marginulata 0 8 ## 3 Achnanthes minutissima 0 0 ## 4 Achnanthes sp. 0 0 ## 5 Actinella punctata 0 3 ## 6 Anomoeoneis serians 0 5 ## 7 Anomoeoneis serians var. brachysira 0 3 ## 8 Anomoeoneis vitrea 0 0 ## 9 Caloneis ventricosa var. minuta 0 0 ## 10 Cocconeis sp. 0 0 ## # ... with 2,118 more rows This form of data is particularly useful because it contains one row per measurement, and looses no data. When finished constructing the pipe, assign to a variable: arnold_counts &lt;- arnold_counts_excel %&gt;% gather(key = depth_cm, value = valve_count, -taxon) %&gt;% mutate(depth_cm = as.numeric(depth_cm)) %&gt;% mutate(valve_count = if_else(is.na(valve_count), 0, valve_count)) Things we can do with the data in this form: Use a grouped mutate to calculate relative abundance: arnold_rel_abund &lt;- arnold_counts %&gt;% group_by(depth_cm) %&gt;% mutate(relative_abundance_percent = valve_count / sum(valve_count) * 100) %&gt;% ungroup() arnold_rel_abund ## # A tibble: 2,128 x 4 ## taxon depth_cm valve_count relative_abundance_per… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Achnanthes linearis fo. c… 0 0 0 ## 2 Achnanthes marginulata 0 8 2.07 ## 3 Achnanthes minutissima 0 0 0 ## 4 Achnanthes sp. 0 0 0 ## 5 Actinella punctata 0 3 0.775 ## 6 Anomoeoneis serians 0 5 1.29 ## 7 Anomoeoneis serians var. … 0 3 0.775 ## 8 Anomoeoneis vitrea 0 0 0 ## 9 Caloneis ventricosa var. … 0 0 0 ## 10 Cocconeis sp. 0 0 0 ## # ... with 2,118 more rows Summarise by taxon, find most common taxa: arnold_rel_abund %&gt;% group_by(taxon) %&gt;% summarise( min_rel_abund = min(relative_abundance_percent), max_rel_abund = max(relative_abundance_percent), mean_rel_abund = mean(relative_abundance_percent) ) %&gt;% arrange(desc(max_rel_abund)) ## # A tibble: 133 x 4 ## taxon min_rel_abund max_rel_abund mean_rel_abund ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Fragilaria construens 0 30.8 1.92 ## 2 Fragilaria virescens var. b… 0 25.6 3.08 ## 3 Cymbella hebridica 0 23.7 7.21 ## 4 Melosira distans 0 23.5 7.18 ## 5 Pinnularia biceps 0 21.1 7.13 ## 6 Pinnularia microstauron 0 20.6 2.68 ## 7 Fragilaria brevistriata 0 15.2 0.953 ## 8 Fragilaria pinnata 0 15 0.954 ## 9 Navicula subtilissima 0 14.9 6.21 ## 10 Anomoeoneis serians var. br… 0 13.0 4.78 ## # ... with 123 more rows Summarise by depth, find depths with greatest richness: arnold_rel_abund %&gt;% group_by(depth_cm) %&gt;% summarise( n_valves = sum(valve_count), total_rel_abund = sum(relative_abundance_percent), n_taxa = sum(valve_count &gt; 0) ) ## # A tibble: 16 x 4 ## depth_cm n_valves total_rel_abund n_taxa ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 0 387 100 44 ## 2 5 489 100 50 ## 3 45 398 100 51 ## 4 75 368 100 40 ## 5 115 484 100 44 ## 6 175 384 100 51 ## 7 235 346 100 47 ## 8 275 381 100 47 ## 9 325 339 100 50 ## 10 375 394 100 40 ## 11 425 245 100 36 ## 12 445 382 100 44 ## 13 475 386 100 44 ## 14 495 384 100 47 ## 15 525 375 100 42 ## 16 555 400 100 29 Create form of data with one row per depth value (this is almost the same as the arnold_counts_csv that we loaded earlier): arnold_rel_abund %&gt;% select(taxon, depth_cm, relative_abundance_percent) %&gt;% spread(key = taxon, value = relative_abundance_percent) ## # A tibble: 16 x 134 ## depth_cm `Achnanthes linearis … `Achnanthes margin… `Achnanthes minuti… ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 2.07 0 ## 2 5 0 2.25 0 ## 3 45 0 1.76 0 ## 4 75 0 3.26 0 ## 5 115 0 1.24 0 ## 6 175 0 3.39 0 ## 7 235 0 6.07 0 ## 8 275 0 6.56 0.262 ## 9 325 0 5.90 0.885 ## 10 375 0 1.02 0 ## 11 425 0.816 4.90 0 ## 12 445 1.57 3.93 0 ## 13 475 0 6.22 0 ## 14 495 0 3.12 0 ## 15 525 0 1.33 5.6 ## 16 555 0 0 0 ## # ... with 130 more variables: `Achnanthes sp.` &lt;dbl&gt;, `Actinella ## # punctata` &lt;dbl&gt;, `Anomoeoneis serians` &lt;dbl&gt;, `Anomoeoneis serians ## # var. brachysira` &lt;dbl&gt;, `Anomoeoneis vitrea` &lt;dbl&gt;, `Caloneis ## # ventricosa var. minuta` &lt;dbl&gt;, `Cocconeis sp.` &lt;dbl&gt;, `Cyclotella ## # glomerata` &lt;dbl&gt;, `Cyclotella stelligera` &lt;dbl&gt;, `Cymbella ## # cistula` &lt;dbl&gt;, `Cymbella gaeumannii` &lt;dbl&gt;, `Cymbella ## # hebridica` &lt;dbl&gt;, `Cymbella laevis` &lt;dbl&gt;, `Cymbella lunata` &lt;dbl&gt;, ## # `Cymbella microcephala` &lt;dbl&gt;, `Cymbella minuta` &lt;dbl&gt;, `Cymbella ## # sinuata` &lt;dbl&gt;, `Cymbella sp.` &lt;dbl&gt;, `Diploneis elliptica` &lt;dbl&gt;, ## # `Diploneis marginestriata` &lt;dbl&gt;, `Diploneis oculata` &lt;dbl&gt;, `Eunotia ## # arcus` &lt;dbl&gt;, `Eunotia assymetrica` &lt;dbl&gt;, `Eunotia bactriana` &lt;dbl&gt;, ## # `Eunotia bidentula` &lt;dbl&gt;, `Eunotia bigibba` &lt;dbl&gt;, `Eunotia ## # curvata` &lt;dbl&gt;, `Eunotia diodon` &lt;dbl&gt;, `Eunotia elegans` &lt;dbl&gt;, ## # `Eunotia exigua` &lt;dbl&gt;, `Eunotia fallax` &lt;dbl&gt;, `Eunotia ## # flexuosa` &lt;dbl&gt;, `Eunotia gibbosa` &lt;dbl&gt;, `Eunotia hexaglyphis` &lt;dbl&gt;, ## # `Eunotia incisa` &lt;dbl&gt;, `Eunotia major` &lt;dbl&gt;, `Eunotia ## # microcephala` &lt;dbl&gt;, `Eunotia monodon` &lt;dbl&gt;, `Eunotia ## # naegelii` &lt;dbl&gt;, `Eunotia pectinalis` &lt;dbl&gt;, `Eunotia pectinalis var. ## # minor` &lt;dbl&gt;, `Eunotia perpusilla` &lt;dbl&gt;, `Eunotia praerupta` &lt;dbl&gt;, ## # `Eunotia serra` &lt;dbl&gt;, `Eunotia soleirolii` &lt;dbl&gt;, `Eunotia ## # spp.` &lt;dbl&gt;, `Eunotia sudetica` &lt;dbl&gt;, `Eunotia suecica` &lt;dbl&gt;, ## # `Eunotia tenella` &lt;dbl&gt;, `Eunotia triodon` &lt;dbl&gt;, `Eunotia ## # vanheurckii` &lt;dbl&gt;, `Eunotia vanheurckii var. intermedia` &lt;dbl&gt;, ## # `Fragilaria brevistriata` &lt;dbl&gt;, `Fragilaria constricta` &lt;dbl&gt;, ## # `Fragilaria constricta fo. stricta` &lt;dbl&gt;, `Fragilaria ## # construens` &lt;dbl&gt;, `Fragilaria construens var. binodis` &lt;dbl&gt;, ## # `Fragilaria construens var. pumila` &lt;dbl&gt;, `Fragilaria construens var. ## # venter` &lt;dbl&gt;, `Fragilaria pinnata` &lt;dbl&gt;, `Fragilaria sp.` &lt;dbl&gt;, ## # `Fragilaria virescens` &lt;dbl&gt;, `Fragilaria virescens var. ## # birostrata` &lt;dbl&gt;, `Frustulia rhomboides` &lt;dbl&gt;, `Frustulia rhomboides ## # var. capitata` &lt;dbl&gt;, `Frustulia rhomboides var. crassinervia` &lt;dbl&gt;, ## # `Frustulia rhomboides var. saxonica` &lt;dbl&gt;, `Gomphonema ## # angustatum` &lt;dbl&gt;, `Gomphonema gracile` &lt;dbl&gt;, `Gomphonema ## # parvulum` &lt;dbl&gt;, `Gomphonema sp.` &lt;dbl&gt;, `Melosira distans` &lt;dbl&gt;, ## # `Melosira distans var. africana (small) SER ADIR` &lt;dbl&gt;, `Melosira ## # distans var. lirata` &lt;dbl&gt;, `Melosira distans var. lirata fo. ## # seriata` &lt;dbl&gt;, `Melosira italica var. subarctica` &lt;dbl&gt;, `Melosira ## # sp.` &lt;dbl&gt;, `Navicula angusta` &lt;dbl&gt;, `Navicula gysingensis` &lt;dbl&gt;, ## # `Navicula mediocris` &lt;dbl&gt;, `Navicula minima` &lt;dbl&gt;, `Navicula ## # monmouthiana-stodderi` &lt;dbl&gt;, `Navicula mutica` &lt;dbl&gt;, `Navicula ## # notha` &lt;dbl&gt;, `Navicula pseudoscutiformis` &lt;dbl&gt;, `Navicula ## # radiosa` &lt;dbl&gt;, `Navicula sp.` &lt;dbl&gt;, `Navicula subtilissima` &lt;dbl&gt;, ## # `Navicula tenuicephala` &lt;dbl&gt;, `Navicula vanheurckii` &lt;dbl&gt;, `Neidium ## # affine` &lt;dbl&gt;, `Neidium affine var. longiceps` &lt;dbl&gt;, `Neidium ## # bisulcatum` &lt;dbl&gt;, `Neidium herrmannii` &lt;dbl&gt;, `Neidium iridis` &lt;dbl&gt;, ## # `Neidium iridis var. amphigomphus` &lt;dbl&gt;, `Neidium sp.` &lt;dbl&gt;, ## # `Nitzschia acuta` &lt;dbl&gt;, `Nitzschia dissipata` &lt;dbl&gt;, `Nitzschia ## # linearis` &lt;dbl&gt;, … Use a left-join to add age-depth info: arnold_age_depth &lt;- read_excel( &quot;data/lake_arnold_valve_counts.xlsx&quot;, sheet = &quot;age depth model&quot;, skip = 1 ) arnold_rel_abund %&gt;% left_join(arnold_age_depth, by = &quot;depth_cm&quot;) %&gt;% select(taxon, depth_cm, age_bp, everything()) ## # A tibble: 2,128 x 5 ## taxon depth_cm age_bp valve_count relative_abundance_p… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Achnanthes linearis … 0 -39 0 0 ## 2 Achnanthes marginula… 0 -39 8 2.07 ## 3 Achnanthes minutissi… 0 -39 0 0 ## 4 Achnanthes sp. 0 -39 0 0 ## 5 Actinella punctata 0 -39 3 0.775 ## 6 Anomoeoneis serians 0 -39 5 1.29 ## 7 Anomoeoneis serians … 0 -39 3 0.775 ## 8 Anomoeoneis vitrea 0 -39 0 0 ## 9 Caloneis ventricosa … 0 -39 0 0 ## 10 Cocconeis sp. 0 -39 0 0 ## # ... with 2,118 more rows Filter to only include some taxa: Find common taxa: common_taxa &lt;- arnold_rel_abund %&gt;% group_by(taxon) %&gt;% summarise( max_rel_abund = max(relative_abundance_percent) ) %&gt;% filter(max_rel_abund &gt;= 20) %&gt;% pull(taxon) common_taxa ## [1] &quot;Cymbella hebridica&quot; ## [2] &quot;Fragilaria construens&quot; ## [3] &quot;Fragilaria virescens var. birostrata&quot; ## [4] &quot;Melosira distans&quot; ## [5] &quot;Pinnularia biceps&quot; ## [6] &quot;Pinnularia microstauron&quot; Filter the counts: arnold_rel_abund %&gt;% filter(taxon %in% common_taxa) ## # A tibble: 96 x 4 ## taxon depth_cm valve_count relative_abundance_pe… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Cymbella hebridica 0 24 6.20 ## 2 Fragilaria construens 0 0 0 ## 3 Fragilaria virescens var. … 0 99 25.6 ## 4 Melosira distans 0 0 0 ## 5 Pinnularia biceps 0 0 0 ## 6 Pinnularia microstauron 0 0 0 ## 7 Cymbella hebridica 5 42 8.59 ## 8 Fragilaria construens 5 0 0 ## 9 Fragilaria virescens var. … 5 90 18.4 ## 10 Melosira distans 5 1 0.204 ## # ... with 86 more rows 4.4 Exporing data use write_csv, writexl::write_xlsx, to write output 4.5 Summary Tutorial summary Draws from data transformation and data import from R for Data Science. References "],
["strat-diagrams.html", "Tutorial 5 Creating Stratigraphic Diagrams 5.1 Prerequisites 5.2 Workflow 5.3 General stratigraphic diagrams 5.4 Exercises 5.5 Species composition diagrams 5.6 Exercises 5.7 Summary", " Tutorial 5 Creating Stratigraphic Diagrams Creating beautiful stratigraphic diagrams is difficult in any program, and while it is not necessarily easier to create beautiful digrams in R the first time, R becomes useful when the data used to create the graph get updated, requiring you to re-make the plot. In the course of a thesis, one can re-make a figure many, many times with various modifications. Learning to create publication-ready stratigraphic plots in R is a front-end investment of time that becomes useful after the first few rounds of revisions. This tutorial is designed to give you the tools to make such diagrams with your own data. 5.1 Prerequisites The prerequisites for this tutorial are the tidyverse package, the gridExtra package, and the analogue package. If you haven’t installed the analogue or gridExtra packages yet, you’ll have to install them using install.packages(). install.packages(&quot;analogue&quot;) install.packages(&quot;gridExtra&quot;) Load the tidyverse when you’re done! We will load the other packages when we use functions that require them below. library(tidyverse) Finally, you will need to obtain the example data. In this tutorial, we will use the Lake Arnold diatom counts tidy CSV version of the data (Whitehead et al. 1989), and the Halifax geochemistry data. If you have these files downloaded you can load them yourself (see Tutorial 4), or you can copy/paste the following code to load the two datasets. halifax_geochem &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/halifax_geochem.csv&quot;, col_types = cols(.default = col_guess()) ) arnold_counts &lt;- read_csv( &quot;http://paleolimbot.github.io/r4paleolim/data/lake_arnold_valve_counts_tidy.csv&quot;, col_types = cols(.default = col_guess()) ) 5.2 Workflow It’s worth mentioning a bit about how one might go about integrating R into one’s figure-creating workflow. I suggest creating a file (something like create_figures.R) that loads the data, creates the figures, and saves the figures, within an RStudio project that also contains the data files. Keeping the data needed to create the figures and the script used to create the figures close means that you can reproduce the figure if you need to change the script (or change the data!), and using an RStudio project means you can move the folder around your computer (or to somebody else’s computer) and your scripts won’t change. I usually have an RStudio project with a subdirectory for data-raw (the data from the instrument/tech/emailed from other lab), data (the user-modified version of the files in data-raw that are R-friendly), and figures (the R-generated figures). 5.3 General stratigraphic diagrams Stratigraphic diagrams are at heart, a set of plots that share a Y axis. The Y-axis represents time, which can be expressed as depth or as some unit of actual time (e.g., AD 2018, or 1200 years BP), and the X-axis is the value of each parameter. We will use the ggplot2 package to create these graphics for non-species data, and the analogue package to create the graphics for species composition data. 5.3.1 Data preparation Getting your data in a form that is usable by the plotting function is most of the battle to creating a figure. In the case of ggplot(), we need the data to be in a “parameter-long” form, with one row for each measurement (each point on the graph). In Tutorial 4 we learned how to use gather() to turn a “parameter-wide” data frame into a “parameter-long” data frame. We are mostly going to focus on plotting the Pockwock Lake core, so we will also filter the data to include only one core for now. halifax_geochem_meas &lt;- halifax_geochem %&gt;% filter(core_id == &quot;POC15-2&quot;) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) halifax_geochem_meas ## # A tibble: 312 x 5 ## core_id depth_cm age_ad param value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 POC15-2 0 2016. C_percent NA ## 2 POC15-2 0.5 2015. C_percent 20.1 ## 3 POC15-2 1 2014. C_percent NA ## 4 POC15-2 1.5 2013. C_percent 21.5 ## 5 POC15-2 2 2011. C_percent 20.5 ## 6 POC15-2 2.5 2009. C_percent 20.2 ## 7 POC15-2 3 2006. C_percent 20.1 ## 8 POC15-2 3.5 2003. C_percent 19.0 ## 9 POC15-2 4 2000. C_percent 17.9 ## 10 POC15-2 4.5 1997. C_percent 16.8 ## # ... with 302 more rows 5.3.2 Plotting a single core Plotting a single core with ggplot() involves several steps: The initial ggplot() call, where we set which columns will get mapped to the x and y values for each layer. Two layers: geom_path() and geom_point() (we don’t use geom_line() because it was written by non-paleolimnologists and connects the line in odd ways) Specify how data are divided between facets using facet_wrap(). We need the scales to be free on the X-axis because each parameter has a different range of values, however the Y-axis should be the same for all facets. Reverse the Y-axis, so that a depth of 0 is at the top. Remove the X label, and set the Y label to “Depth (cm)”. halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) 5.3.3 Changing the colours The default colour scheme in ggplot2 is great for the web, but not so much for publication. I usually use theme_bw(), which is the black-and-white version of the default theme. There are several others, including theme_minimal(), theme_classic(), theme_linedraw(), and many more. You can add them to the end of your plot like so: halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) + theme_bw() Alternatively, you can use the following line to set your theme for the rest of your R session! I usually set the theme to theme_bw() right under my call to library(tidyverse) in a script. theme_set(theme_bw()) 5.3.4 Facet configuration The facet_wrap() function has nrow and ncol arguments that allow customization of how facets are laid out. Sometimes changing the figure size is also helpful, which can be done when the figure is exported using ggsave(). In general, you should only set one of nrow or ncol. halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;, ncol = 4) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) 5.3.5 Reordering facets To control the orderering of the facets, we need to turn the param column into a factor(), which is kind of like a “multiple choice” vector that stores the order of its choices. We first need to create a character vector that defines the order, use mutate() to create a new column containing the facet label as a factor, then make facet_wrap() use that column to create the facets instead of param. facet_order &lt;- c( &quot;Ti_percent&quot;, &quot;K_percent&quot;, &quot;C_percent&quot;, &quot;C/N&quot;, &quot;d13C_permille&quot;, &quot;d15N_permille&quot; ) halifax_geochem_meas %&gt;% mutate(facet = factor(param, levels = facet_order)) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~facet, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) 5.3.6 Relabeling facets When using facet_wrap(), ggplot2 uses the value of each unique value in a column to create the label. This means that we need to rename each item to a suitable label prior to feeding it in to ggplot(). I think the easiest way to do this is fct_recode(), because it also keeps the order of the input (if you’ve already set the input to be a factor()), and you only have to rename the values that need renaming. (Note: I’ve use the unicode superscript 1-9 characters to get the superscript effect, because the other way is much harder. You can copy and paste these, or google superscript 1 unicode). halifax_geochem_meas %&gt;% mutate(facet_label = fct_recode( param, &quot;Ti (%)&quot; = &quot;Ti_percent&quot;, &quot;K (%)&quot; = &quot;K_percent&quot;, &quot;C (%)&quot; = &quot;C_percent&quot;, &quot;δ¹³C (‰)&quot; = &quot;d13C_permille&quot;, &quot;δ¹⁵N (‰)&quot; = &quot;d15N_permille&quot; )) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~facet_label, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) If the unicode superscript effect doesn’t work on your computer (it doesn’t work for \\(\\delta^{15}\\text{N}\\)) on my computer), you will have to resort to plotmath. This is a custom way R invented to render complex formatting, and you can use it with ggplot2 in various ways. The best way to implement this to start is to copy and paste, and check out ?plotmath if you’re curious what the syntax is. The key is to relabel the facets to very specific looking text (if in doubt, surround everything in single quotes like this: 'C/N'), and then use labeller = label_parsed within facet_wrap() (also works in facet_grid()). halifax_geochem_meas %&gt;% mutate(facet_label = fct_recode( param, &quot;&#39;Ti (%)&#39;&quot; = &quot;Ti_percent&quot;, &quot;&#39;K (%)&#39;&quot; = &quot;K_percent&quot;, &quot;&#39;C (%)&#39;&quot; = &quot;C_percent&quot;, &quot;delta ^ 13 * C&quot; = &quot;d13C_permille&quot;, &quot;delta ^ 15 * N&quot; = &quot;d15N_permille&quot;, &quot;&#39;C/N&#39;&quot; = &quot;C/N&quot; )) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~facet_label, scales = &quot;free_x&quot;, labeller = label_parsed) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) 5.3.7 Adding annotations In general, adding text to the plot is difficult and not advisable. Adding horizontal lines and rectangles to highlight a particular region of the plot is much easier, and I have rarely had to resort to adding actual text to a plot using ggplot2. If this is critical to your application, you can use ggsave() to export a .svg file or .pdf file, and import it into your favourite vector drawing program (I happen to like Inkscape). Horizontal lines can be added using geom_hline(). When using the yintercept argument, a horizontal line will be drawn on all panels. halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_hline(yintercept = c(7, 14, 21), alpha = 0.7, lty = 2) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) To only draw on some panels, you will need to create a tibble with a column that specifies the facet. A small example: hline_data &lt;- tibble( param = &quot;C/N&quot;, depth = 14 ) halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_hline( aes(yintercept = depth), data = hline_data, lty = 2, alpha = 0.7 ) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) Rectangles can also be useful to draw in the background to highlight a range of depths. Rectangles also require tibble that specifies their appearance, which can contain the facet variable if the rectangle should only be drawn on some facets. Using xmin = -Inf and xmax = Inf ensures that the rectangles touch the edge of each facet. rect_data &lt;- tibble( max_depth = 21, min_depth = 14 ) halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_rect( aes(ymin = min_depth, ymax = max_depth), data = rect_data, alpha = 0.3, xmin = -Inf, xmax = Inf, inherit.aes = FALSE ) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) 5.3.8 A second axis for ages Depending on the application, ages can be used directly on the Y-axis, or you can include depth on the Y-axis and use a second axis on the right for ages. This can be done using scale_y_reverse() with the sec.axis argument. This axis is created using a one-to-one transformation, which requires the age-depth information as a tibble. Here I use a transformation function based on approx(), which, if you make sure your age-depth data frame is the same as the pockwock one, you should be able to safely copy and paste to add to your plot. pockwock_age_depth &lt;- halifax_geochem %&gt;% filter(core_id == &quot;POC15-2&quot;) %&gt;% select(depth_cm, age_ad) halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse( sec.axis = sec_axis( trans = ~approx(pockwock_age_depth, xout = .)$y, name = &quot;Age (Year AD)&quot;, breaks = c(2000, 1950, 1900, 1850, 1800, 1750) ), expand = c(0, 0) ) + labs(x = NULL, y = &quot;Depth (cm)&quot;) 5.3.9 Multiple cores Plotting multiple cores can happen in a few ways. First, you can map the core_id column to the colour aesthetic (you could use the linetype aesthetic if you need black and white output). You can specify the legend label using the labs() function. halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) %&gt;% # add colour = core_id to aesthetics ggplot(aes(y = depth_cm, x = value, colour = core_id)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;, colour = &quot;Core ID&quot;) Second, you can use facet_grid() instead of facet_wrap(). Here you can use age or depth on the y axis, although you can’t use the second axis trick from above to have dates as a second axis. halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + # use facet_grid instead of facet_wrap facet_grid(core_id ~ param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;, colour = &quot;Core ID&quot;) For both of these, you can use the same tricks we used to change the order of the facets to change the order and labelling of the end result. 5.3.10 Overlapping x-axis labels The default placement of labels in ggplot2 can result in labels that overlap and look ugly in the final product. There are a few solutions, including (1) Rotate the labels by 90 degrees (this works in most circumstances): halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_grid(core_id~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;, colour = &quot;Core ID&quot;) + # modify axis labels theme( axis.text.x = element_text(angle = 90, vjust = 0.5) ) You can also (2) make the font size for the labels smaller (the value is in points): halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_grid(core_id~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;, colour = &quot;Core ID&quot;) + # modify axis labels theme( axis.text.x = element_text(size = 7) ) Finally, you can (3) suggest a number of breaks to use in scale_x_continuous(): halifax_geochem %&gt;% filter(core_id %in% c(&quot;POC15-2&quot;, &quot;MAJ15-1&quot;)) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_grid(core_id~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;, colour = &quot;Core ID&quot;) + # x axis scale scale_x_continuous(breaks = scales::extended_breaks(n = 3)) 5.3.11 Saving a plot You can use the same strategy we used in Tutorial 3 to save the plots we created in this section. The easiest way to do this is to save the plot to an object, then use ggsave() to write the object to disk. halifax_geochem_plot &lt;- halifax_geochem_meas %&gt;% ggplot(aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) ggsave( plot = halifax_geochem_plot, filename = &quot;geochem_plot_file_name.png&quot;, height = 4, width = 6.5, units = &quot;in&quot;, dpi = 300 ) ## Warning: Removed 1 rows containing missing values (geom_path). ## Warning: Removed 10 rows containing missing values (geom_point). You can also save files as .pdf and .svg, but .png is probably the most reliable for importing into Word documents. If you need to edit the file in a vector drawing program afterward (or you need to give the final result to a journal), using .pdf or .svg is probably best. Note that exporting to .svg requires the svglite package. 5.4 Exercises Make a simple stratigraphic diagram of the “BEN15-2” core. Use age_ad on the Y-axis. Your plot should look like this: halifax_geochem %&gt;% filter(core_id == &quot;BEN15-2&quot;) %&gt;% gather(key = param, value = value, -core_id, -depth_cm, -age_ad) %&gt;% ggplot(aes(y = age_ad, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + labs(x = NULL, y = &quot;Depth (cm)&quot;) Make a stratigraphic diagram of the “FCL16-1” and “LEM16-1” cores. For bonus points, use proper sub/superscripts for the delta parameters and keep C/N, C, and stable isotopes together, include units in parentheses for all parameters, and use age_ad on the Y-axis. In the end, your plot (with bonus marks) should look like this: 5.5 Species composition diagrams Species composition diagrams are like other types of strat diagrams, except they have long variable names and generally require scaling of the space such that 10% on one facet is the same distance as 10% on another facet. There are two approaches for this: using ggplot2 is more verbose but more flexible (you can use most of the tips/tricks above to add secondary axes, horizontal lines, etc.), and using the Stratiplot() function in the analogue package is less verbose but requires that you have your data in a very specific form. We will go over both approaches here, but if you can make ggplot2 work for you, the plot looks much nicer. 5.5.1 Using ggplot2 5.5.1.1 Data setup Similar to non-speices data, ggplot2 needs the data to be in “parameter-long” form. Usually the value plotted on the X-axis of species composition plots is a relative abundance (in percent), which we can calculate using a grouped mutate(). arnold_counts &lt;- arnold_counts_csv %&gt;% gather(-age_bp, -depth_cm, key = taxon, value = valve_count) %&gt;% group_by(depth_cm) %&gt;% mutate(relative_abundance_percent = valve_count / sum(valve_count) * 100) %&gt;% ungroup() arnold_counts ## # A tibble: 2,128 x 5 ## depth_cm age_bp taxon valve_count relative_abundance_… ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 -39 Achnanthes marginulata 8 2.07 ## 2 5 12 Achnanthes marginulata 11 2.25 ## 3 45 445 Achnanthes marginulata 7 1.76 ## 4 75 795 Achnanthes marginulata 12 3.26 ## 5 115 1373 Achnanthes marginulata 6 1.24 ## 6 175 2314 Achnanthes marginulata 13 3.39 ## 7 235 3469 Achnanthes marginulata 21 6.07 ## 8 275 4243 Achnanthes marginulata 25 6.56 ## 9 325 5218 Achnanthes marginulata 20 5.90 ## 10 375 6196 Achnanthes marginulata 4 1.02 ## # ... with 2,118 more rows Because there are many taxa, we will restrict our plot to those with a maximum relative abundance of 10% or more. We need this as a vector so that we can filter() the arnold_counts data above and change the taxon column to a factor() so that it is plotted in a specific order. Generally this order is some preference gradient, but that isn’t a part of this particular dataset. Instead, we will order from least abundant to most abundant. arnold_common_taxa &lt;- arnold_counts %&gt;% group_by(taxon) %&gt;% summarise(max_rel_abund = max(relative_abundance_percent)) %&gt;% filter(max_rel_abund &gt;= 10) %&gt;% arrange(max_rel_abund) %&gt;% pull(taxon) arnold_common_taxa ## [1] &quot;Surirella delicatissima&quot; ## [2] &quot;Anomoeoneis serians var. brachysira&quot; ## [3] &quot;Navicula subtilissima&quot; ## [4] &quot;Fragilaria pinnata&quot; ## [5] &quot;Fragilaria brevistriata&quot; ## [6] &quot;Pinnularia microstauron&quot; ## [7] &quot;Pinnularia biceps&quot; ## [8] &quot;Melosira distans&quot; ## [9] &quot;Cymbella hebridica&quot; ## [10] &quot;Fragilaria virescens var. birostrata&quot; ## [11] &quot;Fragilaria construens&quot; arnold_counts_common &lt;- arnold_counts %&gt;% filter(taxon %in% arnold_common_taxa) %&gt;% mutate(taxon = factor(taxon, levels = arnold_common_taxa)) %&gt;% arrange(taxon) arnold_counts_common ## # A tibble: 176 x 5 ## depth_cm age_bp taxon valve_count relative_abundance… ## &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 -39 Surirella delicatissima 49 12.7 ## 2 5 12 Surirella delicatissima 37 7.57 ## 3 45 445 Surirella delicatissima 16 4.02 ## 4 75 795 Surirella delicatissima 23 6.25 ## 5 115 1373 Surirella delicatissima 22 4.55 ## 6 175 2314 Surirella delicatissima 28 7.29 ## 7 235 3469 Surirella delicatissima 11 3.18 ## 8 275 4243 Surirella delicatissima 24 6.30 ## 9 325 5218 Surirella delicatissima 5 1.47 ## 10 375 6196 Surirella delicatissima 2 0.508 ## # ... with 166 more rows 5.5.1.2 Plotting one core Using ggplot2 to plot species composition strat diagrams is similar to plotting geochemical data, with three important differences: the geometry is usually a horizontal bar plot, the facet labels are so long that they need to be rotated, and the horizontal distance in each facet must be equal between facets (so that 10% relative abundance is the same on the leftmost facet as the rightmost facet). We solve the first by replacing geom_path() and geom_point() with geom_segment(), and the third by replacing facet_wrap() with facet_grid() using space = &quot;free_x&quot; to keep the distance on each facet comparable in the x direction. Setting the breaks on the x-axis helps keep the axes less cluttered and maintains the idea of equal space visually. ggplot( arnold_counts_common, aes(y = depth_cm, x = relative_abundance_percent) ) + # draw horizontal lines of the appropriate length for each depth geom_segment(aes(xend = 0, yend = depth_cm), lwd = 1) + # facet by taxon, keeping distance on the x axis comparable # between facets facet_grid(~taxon, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + # have the same breaks for all x axes scale_x_continuous(breaks = c(0, 10, 20, 30)) + # reverse the y axis for depth scale_y_reverse() + labs(x = &quot;Relative Abundance (%)&quot;, y = &quot;Depth (cm)&quot;) The problem of rotated and partially overlapping facet labels is one that takes some code to deal with. The good news is, the code is the same regardless of which plot you are trying to create, so you can copy/paste it for any plot that needs rotated facet labels. We do this in two steps: rotate and align the facet labels within theme(), and then use what can only be described as voodoo to eliminate the default clipping used by ggplot2. species_plot_obj &lt;- ggplot( arnold_counts_common, aes(y = depth_cm, x = relative_abundance_percent) ) + # draw horizontal lines of the appropriate length for each depth geom_segment(aes(xend = 0, yend = depth_cm), lwd = 1) + # facet by taxon, keeping distance on the x axis comparable # between facets facet_grid(~taxon, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + # reverse the y axis for depth scale_y_reverse() + # make all facets use the same break values # (helps with cluttered breaks) scale_x_continuous(breaks = c(0, 10, 20, 30)) + # set the x and y labels labs(x = &quot;Relative Abundance (%)&quot;, y = &quot;Depth (cm)&quot;) + # customize the appearance theme( # rotate the facet labels strip.text.x = element_text(angle = 60, hjust = 0, vjust = 0), # turn off the label background strip.background = element_blank() ) # voodoo that makes it so that facet labels can overlap # https://stackoverflow.com/questions/49740215/ggplot-facet-grid-label-cut-off species_plot_grob &lt;- ggplotGrob(species_plot_obj) for(i in which(grepl(&quot;strip-t&quot;, species_plot_grob$layout$name))){ species_plot_grob$grobs[[i]]$layout$clip &lt;- &quot;off&quot; } # needed to draw the modified plot_grob grid::grid.draw(species_plot_grob) 5.5.1.3 Saving a plot Because we have modified the plot after it is has been built, we need to use the base-R way of saving things. This is done using the pdf(), png() and svg() functions (and calling dev.off() afterward). Call grid::grid.draw() in the middle like this: png( &quot;my_species_plot.png&quot;, width = 6.5, height = 4, res = 300, units = &quot;in&quot; ) grid::grid.draw(species_plot_grob) dev.off() pdf( &quot;my_species_plot.pdf&quot;, width = 6.5, height = 4 ) grid::grid.draw(species_plot_grob) dev.off() 5.5.1.4 Adjusting spacing For more fine-tuned control of the appearance, you can use various arguments within theme(). The two that I’ve used in this situation are plot.margin to add some padding to the right (this helps with the occasional cutoff rightmost facet label), and panel.spacing.x to adjust the spacing between panels. ... + theme( ..., # add some margin to the right of the plot so that the rightmost label # isn&#39;t cut off # c(top, right, bottom, left) plot.margin = unit(c(0, 0.5, 0, 0), &quot;inches&quot;), # adjust spacing between facets panel.spacing.x = unit(0.05, &quot;inches&quot;) ) 5.5.1.5 Non-species data Often strat diagrams include some other kind of data in addition to the species data, like a PC1 summary or diatom-inferred pH. I’ll calculate a few diversity indicies for this dataset as a demonstration. species_diversity &lt;- arnold_counts %&gt;% group_by(depth_cm) %&gt;% summarise( richness = sum(valve_count != 0), simpsons = 1 - sum((relative_abundance_percent / 100) ^ 2), hill_n2 = 1 / sum((relative_abundance_percent / 100) ^ 2) ) %&gt;% gather(key = param, value = value, -depth_cm) diversity_plot &lt;- ggplot(species_diversity, aes(y = depth_cm, x = value)) + geom_path() + geom_point() + facet_wrap(~param, scales = &quot;free_x&quot;) + scale_y_reverse() + labs(x = NULL, y = &quot;Depth (cm)&quot;) diversity_plot When using ggplot2, there is no easy way to combine this with a species plot (you will see a way to do this in the analogue package below). The only way I know of to do this is to with ggplot2 is to (1) modify the non-species data such that it has no y-axis label, no y-axis ticks, and no y-axis break labels, (2) remove the plot background from the second plot (to avoid clipping), (3) fudge the plot margins on the second plot so that the plots align properly (below I set the top and bottom margins to 1.74 and 0.30 inches, respectively, but you will have to fudge this yourself), and (4) use the grid.arrange() function from the gridExtra package to combine the two plots (you can set the relative widths, but you should have the number of rows be 1). Make sure to use the “grob” version of the species plot, which kept the species names from being clipped. Make sure that your depth values actually align before removing the axis labels completely! gridExtra::grid.arrange( species_plot_grob, diversity_plot + labs(y = NULL) + scale_y_reverse(labels = NULL) + theme( plot.margin = unit(c(1.74, 0, 0.30, 0), &quot;inches&quot;), axis.ticks.y = element_blank(), plot.background = element_blank() ), nrow = 1, widths = c(2.5, 1) ) You can save this plot by enclosing the grid.arrange() call in png() (or pdf()) and dev.off(). 5.5.2 Using analogue::Stratiplot The analogue package by Gavin Simpson has a number of useful functions for paleolimnologists, including a Stratiplot() function designed to produce stratigraphic plots. I find the ggplot2 version to be more flexible, but the default look and feel works for you, Stratiplot() is definitely easier. Because we are using functions from another package, we have to load the package using library(). # install using install.packages(&quot;analogue&quot;) library(analogue) ## Loading required package: vegan ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.5-1 ## analogue version 0.17-0 5.5.2.1 Data preparation The data required by Stratiplot() is a data frame of relative abundances (as columns). To calculate this from our filtered data, we can use the spread() function to get the data in “parameter wide” form. arnold_rel_abundance_wide &lt;- arnold_counts_common %&gt;% select(depth_cm, age_bp, taxon, relative_abundance_percent) %&gt;% spread(key = taxon, value = relative_abundance_percent) arnold_rel_abundance_wide ## # A tibble: 16 x 13 ## depth_cm age_bp `Surirella delica… `Anomoeoneis seria… `Navicula subti… ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 -39 12.7 0.775 11.4 ## 2 5 12 7.57 1.84 14.9 ## 3 45 445 4.02 4.02 12.6 ## 4 75 795 6.25 3.53 8.97 ## 5 115 1373 4.55 1.45 6.40 ## 6 175 2314 7.29 0.521 7.81 ## 7 235 3469 3.18 0.867 6.07 ## 8 275 4243 6.30 2.62 4.99 ## 9 325 5218 1.47 3.24 6.49 ## 10 375 6196 0.508 3.05 4.57 ## 11 425 7274 4.49 11.4 4.49 ## 12 445 7975 2.88 10.7 3.40 ## 13 475 9018 0.777 10.1 6.48 ## 14 495 9714 0.521 13.0 0.260 ## 15 525 10645 1.07 9.33 0.533 ## 16 555 11240 0 0 0 ## # ... with 8 more variables: `Fragilaria pinnata` &lt;dbl&gt;, `Fragilaria ## # brevistriata` &lt;dbl&gt;, `Pinnularia microstauron` &lt;dbl&gt;, `Pinnularia ## # biceps` &lt;dbl&gt;, `Melosira distans` &lt;dbl&gt;, `Cymbella hebridica` &lt;dbl&gt;, ## # `Fragilaria virescens var. birostrata` &lt;dbl&gt;, `Fragilaria ## # construens` &lt;dbl&gt; 5.5.2.2 Plotting a single core The Stratiplot() function takes two arguments: the first is a version of the data frame we just created without any of the depth information. The second is the depth information as a vector. Stratiplot( arnold_rel_abundance_wide %&gt;% select(-depth_cm, -age_bp), arnold_rel_abundance_wide$depth_cm ) There are many arguments to Stratiplot(), but I found for this example that the following values worked for this particular dataset. In particular, increasing the topPad parameter was needed to keep the species labels from being cutoff. Stratiplot( arnold_rel_abundance_wide %&gt;% select(-depth_cm, -age_bp), arnold_rel_abundance_wide$depth_cm, # sets the x and y labels ylab = &quot;Depth (cm)&quot;, xlab = &quot;Relative abundance (%)&quot;, # adds padding to the top of the plot # to fix cut-off taxa names topPad = 10, # make the plot type a &quot;bar&quot; plot type = &quot;h&quot;, # make the bar colour black col = &quot;black&quot; ) 5.5.2.3 Non-species data Including non-species data is similar to including species data using Stratiplot(), but the varTypes argument needs to specify that the non-species variables should have independently sized axes. This should be a vector with the same number of elements as variables in the plot (I’ve use rep() to repeat “relative” and “absolute” the correct number of times.) species_diversity &lt;- arnold_counts %&gt;% group_by(depth_cm) %&gt;% summarise( richness = sum(valve_count != 0), simpsons = 1 - sum((relative_abundance_percent / 100) ^ 2), hill_n2 = 1 / sum((relative_abundance_percent / 100) ^ 2) ) arnold_rel_abundance_wide_div &lt;- cbind( arnold_rel_abundance_wide, species_diversity %&gt;% select(-depth_cm) ) Stratiplot( arnold_rel_abundance_wide_div %&gt;% select(-depth_cm, -age_bp), arnold_rel_abundance_wide_div$depth_cm, varTypes = c(rep(&quot;relative&quot;, 11), rep(&quot;absolute&quot;, 3)), ylab = &quot;Depth (cm)&quot;, xlab = &quot;Relative abundance (%)&quot;, topPad = 10, type = &quot;h&quot;, col = &quot;black&quot; ) 5.5.2.4 Saving a plot You can save these plots by enclosing the Stratiplot() call in png() (or pdf()) and dev.off(): png( &quot;my_species_plot.png&quot;, width = 6.5, height = 4, res = 300, units = &quot;in&quot; ) Stratiplot( arnold_rel_abundance_wide %&gt;% select(-depth_cm, -age_bp), arnold_rel_abundance_wide$depth_cm, # sets the x and y labels ylab = &quot;Depth (cm)&quot;, xlab = &quot;Relative abundance (%)&quot;, # adds padding to the top of the plot # to fix cut-off taxa names topPad = 10, # make the plot type a &quot;bar&quot; plot type = &quot;h&quot;, # make the bar colour black col = &quot;black&quot; ) dev.off() 5.6 Exercises Use either ggplot2 or analogue to plot the species c(&quot;Surirella delicatissima&quot;, &quot;Anomoeoneis serians var. brachysira&quot;, &quot;Navicula subtilissima&quot;, &quot;Fragilaria pinnata&quot;, &quot;Fragilaria brevistriata&quot;). For bonus points, use ggplot2 and rotate the axis labels. 5.7 Summary In this tutorial, we used ggplot2 and the analogue package to create (and save) stratigraphic diagrams for geochemical and species composition data. Unforunately, I don’t know of any good resources currently available for creating stratigraphic plots in R, although there is an R session at IPA-IAL this year. References "],
["references.html", "References", " References "]
]
